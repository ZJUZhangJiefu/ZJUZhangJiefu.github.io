
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="大观散人">
      
      
        <link rel="canonical" href="https://ZJUZhangJiefu.github.io/OS-Notes/">
      
      
        <link rel="prev" href="../CP/">
      
      
        <link rel="next" href="../Camera%20Model%20and%203D%20Vision/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.6">
    
    
      
        <title>操作系统 - 大观散人的博客</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=仿宋:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"仿宋";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="cyan">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="大观散人的博客" class="md-header__button md-logo" aria-label="大观散人的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            大观散人的博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              操作系统
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="cyan"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="cyan" data-md-color-accent="cyan"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ZJUZhangJiefu/ZJUZhangJiefu.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ZJUZhangJiefu.github.io
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
    
  
  主页

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../CP/" class="md-tabs__link">
          
  
  计算机专业课

        </a>
      </li>
    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../RealNVP/" class="md-tabs__link">
          
  
  深度学习论文

        </a>
      </li>
    
  

    
  

    
  

      
        
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../BasicDGM/" class="md-tabs__link">
          
  
  深度学习专题总结

        </a>
      </li>
    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="大观散人的博客" class="md-nav__button md-logo" aria-label="大观散人的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    大观散人的博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ZJUZhangJiefu/ZJUZhangJiefu.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ZJUZhangJiefu.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    计算机专业课
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            计算机专业课
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    编译原理
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    操作系统
  </span>
  

      </a>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机视觉
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            计算机视觉
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Camera%20Model%20and%203D%20Vision/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    专题汇编——相机模型与立体视觉
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CV-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    复习提纲全解
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../SE/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    软件工程
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../NA-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数值分析
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../AOR-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    应用运筹学基础
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    深度学习论文
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            深度学习论文
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    深度生成模型
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            深度生成模型
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    流模型
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1_1">
            <span class="md-nav__icon md-icon"></span>
            流模型
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RealNVP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    RealNVP
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    GNN
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            GNN
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../A%20Gentle%20Introduction%20to%20Graph%20Neural%20Networks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图神经网络导论
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            Transformer
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Attention%20Is%20All%20You%20Need/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Attention Is All You Need(NIPS 2017)
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    扩散模型
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            扩散模型
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DDPM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Denoising Diffusion Probabilistic Models
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
        
          
          <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    优化器
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5">
            <span class="md-nav__icon md-icon"></span>
            优化器
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Descending%20Through%20A%20Crowded%20Valley/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Descending Through A Crowded Valley
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
        
          
          <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    分子对接
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_6">
            <span class="md-nav__icon md-icon"></span>
            分子对接
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DSDP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DSDP - A Blind Docking Strategy Accelerated by GPUs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_7" >
        
          
          <label class="md-nav__link" for="__nav_3_7" id="__nav_3_7_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    逆合成预测
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_7_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_7">
            <span class="md-nav__icon md-icon"></span>
            逆合成预测
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../G2GT/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    G2GT
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../O-GNN/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    O-GNN
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="">
            
  
  <span class="md-ellipsis">
    深度学习专题总结
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            深度学习专题总结
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../BasicDGM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    深度生成模型基础
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>操作系统</h1>

<p><strong>第二章 操作系统结构</strong><br />
<strong>一、知识点</strong><br />
1.机制决定如何做，策略决定做什么。<br />
<strong>第三章 进程</strong><br />
<strong>一、进程概念</strong><br />
1.进程概念<br />
（1）<strong>资源分配</strong>角度：<strong>资源分配</strong>和<strong>保护</strong>的<strong>单元</strong>。<br />
（2）<strong>运行</strong>角度：<strong>一个正在执行的程序</strong>称为一个<strong>进程</strong>。<br />
2.程序与进程的区别<br />
（1）程序：<strong>被动实体</strong>，即<strong>磁盘上存储的可执行文件</strong>。<br />
（2）进程：<strong>程序</strong>被<strong>加载到内存</strong>后，成为进程。<br />
3.进程的组成部分<br />
（1）代码(<code>code/text</code>)
（2）数据部分(<code>.bss, .data</code>)：存放未初始化、初始化的数据  <br />
（3）程序计数器（<code>PC</code>）、<code>CPU</code>上下文<br />
（4）栈（临时数据，如：函数参数、返回地址、局部变量等）  <br />
（5）堆：用于<strong>动态分配内存</strong>。<br />
<strong>二、进程控制块(<code>Process Control Block, PCB</code>)</strong><br />
1.进程控制块的作用<br />
（1）<strong>创建新进程</strong>时，<strong>分配</strong>一个<strong>进程控制块</strong>。<br />
（2）进程<strong>终止</strong>时，其<strong>进程控制块</strong>被<strong>释放</strong>。<br />
2.进程控制块的组成部分<br />
（1）进程状态<br />
（2）程序计数器<br />
（3）<code>CPU</code>寄存器：存储上下文。<br />
（4）<code>CPU</code>调度信息：优先级、调度队列指针等。<br />
（5）内存管理信息：基地址寄存器、界限寄存器、页表、段表。<br />
（6）<code>I/O</code>状态信息：分配给进程的<code>I/O</code>设备信息、进程打开文件列表。<br />
<strong>三、进程状态</strong><br />
1.进程状态：创建(<code>New</code>)：进程正在被创建；<code>Running</code>：进程指令正在执行；<code>Waiting</code>：进程正在等待某事件发生；<code>Ready</code>：进程就绪，等待分配<code>CPU</code>资源；<code>Terminated</code>：进程终止执行。<br />
2.进程状态转换图<br />
<img alt="" src="../assets/OSFinal/1.JPG" /><br />
3.子进程创建<br />
（1）父子进程资源分配关系：子进程继承父进程的一部分资源；子进程获得新分配资源。<br />
（2）父子进程的运行关系：父进程创建完子进程后，直接继续运行；父进程等待子进程完成后，再运行。<br />
（3）父子进程的地址空间关系：<code>fork</code>产生子进程时，子进程复制父进程地址空间（可采用<strong>写时复制</strong>机制）；子进程执行<code>exec</code>系统调用，将新程序加载到自身地址空间中，覆盖原来拷贝自父进程地址空间的内容。  <br />
4.<code>fork</code>系统调用：父进程创建子进程；子进程拷贝父进程地址空间中的内容，但分配到一个新的<code>pid</code>，并且暂未获得资源分配；返回值：给父进程返回子进程的<code>pid</code>，给子进程返回<code>0</code>，两个进程分别通过自己的返回值判断自己的身份。<br />
·两个进程在<code>fork</code>系统调用后，均继续执行。<br />
4.[题型积累]<code>fork</code>产生的子进程个数<br />
[例1]<br />
<img alt="" src="../assets/OSFinal/4.JPG" /><br />
[解]父进程调用第一个<code>fork</code>，产生子进程；父子进程从第二个<code>fork</code>返回后，分别输出一次，共<code>2</code>次；父进程、子进程各调用第二个<code>fork</code>一次，产生孙进程<code>1, 2</code>；父进程、子进程、孙进程<code>1, 2</code>自第二个<code>fork</code>返回后，各输出<code>1</code>次，共<code>4</code>次；总输出次数：<code>2 + 4 = 6</code><br />
[例2]求执行完代码时的总进程数量。  <br />
<img alt="" src="../assets/OSFinal/5.JPG" /><br />
[解]父进程调用第一个<code>fork</code>，进程数变为<code>2</code>；<code>2</code>个老进程分别调用第二个<code>fork</code>，产生<code>2</code>个新进程。老进程还要调第三个<code>fork</code>；新进程则不调用；第四个<code>fork</code>执行前，共<code>6</code>个进程；执行后，共<code>12</code>个进程，即最终结果。<br />
5.进程终止：进程调用<code>exit</code>系统调用，终止自己；操作系统收回分配给进程的资源；某进程导致其他进程终止。<br />
6.进程等待：父进程等待子进程结束；进程等待某事件发生/资源就绪<br />
<strong>四、进程调度</strong><br />
1.基本模块<br />
（1）进程调度器：选择下一个在<code>CPU</code>上运行的进程，分配运行时间。<br />
（2）调度队列：就绪队列；等待队列（针对每一事件/资源各有一个等待队列，如<code>I/O</code>设备等）<br />
[注]各个进程根据其对资源的需求，在上述调度队列之间移动。<br />
2.调度队列切换图<br />
<img alt="" src="../assets/OSFinal/2.JPG" /><br />
3.上下文切换<br />
（1）上下文切换：保存旧进程的状态信息，加载新进程的状态信息。<br />
（2）上下文保存在<code>PCB</code>中。<br />
（3）上下文开销：上下文切换时，系统无法执行有效任务，带来开销。<br />
（4）用户、内核模式的切换：用户线程上下文保存地点在线程内核栈（<code>pt_regs</code>部分），保存时间：进行上下文，刚进入内核模式时(<code>kernel entry</code>)。<br />
<img alt="" src="../assets/OSFinal/3.JPG" /><br />
4.进程调度程序分类：长期调度程序/作业调度程序(<code>long-term scheduler/job scheduler</code>)：调度频率低，调度时间间隔长，控制多道程序程度；中期调度程序(<code>medium-term scheduler</code>)：可将进程从内存/<code>CPU</code>竞争中移出，降低多道程序程度；进程可在换出后重新换入。<br />
5.进程分类：<code>I/O</code>密集型进程、<code>CPU</code>密集型进程。  <br />
<strong>五、进程间通信(<code>Inter-Process Communication, IPC</code>)</strong> <br />
1.定义<br />
·协作进程使用进程间通信机制，以相互交换数据和信息。<br />
2.作用：信息共享-允许多用户并发访问共享信息；计算加速-多核系统中将特定任务分为子任务，与其余任务并行执行，提高计算速度；系统功能模块化：不同系统功能分为独立的进程或线程；方便：单用户同时执行多任务。<br />
3.<code>IPC</code>基本模型一——共享内存模型：建立一块供协作进程共享的内存区域：进程通过向共享区域读出/写入数据，实现信息交换：额外开销较低，只需在共享区域建立时调用一些相关系统调用，后续无需再调用；更方便，直接从<code>RAM</code>进行读写；实现更困难。<br />
<img alt="" src="../assets/OSFinal/6.JPG" /><br />
4.<code>IPC</code>基本模型二——消息传递模型：通过在协作继承之间交换消息，实现通信；用于交换少量信息，易于实现；额外开销较大，每个系统调用只能完成一个信息传递操作；基本系统调用：<code>send, recv</code>；进程消息传递过程：建立连接-&gt;调用<code>send, recv</code>系统调用-&gt;关闭连接。<br />
<img alt="" src="../assets/OSFinal/7.JPG" /><br />
5.通信链接实现<br />
（1）物理实现：共享内存、硬件总线、网络。<br />
（2）逻辑实现<br />
①直接通信/间接通信 
②同步通信（阻塞通信）/异步通信（非阻塞通信）<br />
·阻塞发送：信息发送者一直阻塞，直到消息被成功接收。<br />
·阻塞接收：信息接收者一直阻塞，直到收到一条消息。<br />
③自动/显式缓冲(<code>explicit buffering</code>)：缓冲(<code>buffering</code>)：消息队列；<code>zero capacity</code>：发送者必须等待接收者；<code>bounded capacity</code>：消息队列已满，则发送者需等待接收者；<code>unbounded capacity</code>：消息队列无限长，发送者无需等待接收者。<br />
6.信号机制：告知目的进程某个事件的发生。<br />
7.管道机制<br />
（1）分类：单向/双向、全双工/半双工、进程是否存在父子关系等。<br />
（2）普通管道：无法从创建管道进程以外的地方访问管道（例：父进程使用普通管道与子进程通信）；生产者-消费者模型，读端、写端；单向通信。<br />
（3）命名管道：访问时，父子进程关系不是必须的；双向通信。<br />
8.客户-服务器通信：套接字(<code>socket</code>)通信-主机间/主机内部通信均可，使用<code>ip + port</code>；远程过程调用(<code>Remote Procedure Call</code>)-提供跨越主机的过程调用抽象(<code>a procedure invocation abstraction accross hosts</code>)；管道通信。<br />
<strong>第四章 线程</strong><br />
<strong>一、线程基本概念</strong>
1.线程基本特点<br />
（1）定义：进程内部的基本执行单元。<br />
（2）线程独有内容：线程<code>ID</code>、程序计数器、寄存器上下文、栈。 <br />
（3）线程共享内容：代码段、数据区域、堆（动态分配内存）、进程打开文件、信号。<br />
<img alt="" src="../assets/OSFinal/8.JPG" /><br />
2.并行类型<br />
（1）数据并行：数据分布于多个计算核，每个计算核执行相同操作。<br />
（2）任务并行：任务分配于多个计算核，每个计算核执行一个独特操作。<br />
3.多线程编程的意义<br />
（1）并发性：一个多线程进程可以一次性完成多个任务。　<br />
（2）响应性：拥有并发活动的程序响应性更强。<br />
（3）资源共享：线程共享内存，无需<code>IPC</code>；在同一地址空间进行并发活动是有利的。<br />
（4）经济性：创建线程、线程上下文切换代价小。<br />
（5）可伸缩性：在多核系统上，一个进程可以一次性执行多个任务；与进程相比，共享程度、经济性均有改善。  <br />
4.线程的缺点<br />
（1）一个线程的<code>failure</code>可能导致整个进程的<code>failure</code>。<br />
（2）消耗内存；不利于内存保护。<br />
5.多线程编程的挑战：数据依赖和一致性问题；线程间的任务分配；线程负载均衡问题；在线程间分割数据；测试与调试。<br />
6.用户线程与内核线程<br />
（1）用户线程运行于<code>user space</code>，内核线程运行于<code>kernel space</code>。<br />
（2）多对一模型：多线程效率更高，额外开销更低；无法利用多处理器架构；若某一用户线程执行阻塞系统调用，则其余线程均会阻塞。<br />
（3）一对一模型：创建一个新的用户线程，则需同时创建一个内核线程；解决了多对一模型的问题，但速度有所下降。<br />
（4）多对多模型：某一线程阻塞，可以创建一个新的内核线程，以防阻塞其余用户线程；可以实现多核处理器上的真正并发运行；新建用户线程不必新建内核线程。<br />
（5）二级模型：同时支持一对一模型、多对多模型。<br />
（6）用户线程特点：位于内核之上，管理无需内核支持；由用户空间线程库完成线程管理。
7.<code>Pthreads</code>：<code>POSIX</code>标准定义的线程规范。<br />
<strong>二、线程研究</strong><br />
1.系统调用<code>fork, exec</code>的语义<br />
（1）线程调用<code>fork</code>的两种可能语义：新进程被创建，且只有一个线程，拷贝自调用<code>fork</code>的线程；新进程被创建，并拷贝调用<code>fork</code>的线程所属的整个进程。<br />
（2）若<code>fork</code>后，新进程立即执行<code>exec</code>，则所有复制内容都被“擦除”，因此<code>fork</code>只复制一个线程较为合适；若新进程不立即执行<code>exec</code>，则可复制整个进程。<br />
2.信号处理的多种选择：将信号传递给信号实际作用的线程；将信号传递给进程中的每个线程；将信号传递给进程中的特定线程；为进程分配一个特定线程，以接收所有信号。<br />
3.安全的线程撤销<br />
（1）异步撤销与延迟撤销：异步撤销(<code>asynchronous calcellation</code>)-线程一收到撤销信号，就立即撤销；延迟撤销(<code>deferred cancellation</code>)-线程不断检查自己是否应该终止，到达撤销点再撤销。<br />
（2）异步撤销与延迟撤销的问题：异步撤销-可能导致状态不一致或同步问题；延迟撤销：多个撤销点不容易实现。<br />
<strong>第五章 进程调度</strong><br />
<strong>一、进程调度基本概念</strong><br />
1.<code>policy</code>和<code>mechanism</code><br />
·<code>policy</code>：所选的调度策略。<br />
·<code>mechanism</code>：操作系统的调度器(<code>dispatcher</code>)组件，使用上下文交换机制，用于进程之间的交换。<br />
2.进程分类：<code>I/O</code>密集型进程、<code>CPU</code>密集型进程。<br />
3.抢占与非抢占调度：按进程在执行过程中是否会被其余进程抢占进行区分。具体而言，如果进程在<code>RUNNIGN-&gt;READY</code>的任何时刻点都可能被抢占，则对应抢占式调度。  <br />
4.<code>CPU</code>调度的考虑因素：<code>CPU</code>使用率、吞吐量（一个时间单元内进程完成的数量）、周转时间（<code>turnaround time</code>，从进程提交到进程完成所需的时间）、等待时间、相应时间。<br />
5.分派器(<code>dispatcher</code>)和分派延迟(<code>dispatch latency</code>)<br />
（1）分派器(<code>dispatcher</code>)：切换到内核模式-&gt;进行进程上下文交换-&gt;切换回用户模式-&gt;使得用户程序从正确位置开始执行。<br />
（2）分派延迟(<code>dispatch latency</code>)：分派程序中止一个进程，并启动另一个进程所需的时间。<br />
6.进程调度队列：就绪队列、设备队列。<br />
<strong>二、进程调度算法</strong><br />
[注]注意区别<code>waiting time</code>和<code>turnaround time</code>两个概念。<br />
1.先到先服务(<code>FCFS, First Come Fitst Served</code>)调度：进程平均等待时间较长；护航效应（所有进程可能都需要等待一个大进程释放<code>CPU</code>）；非抢占式调度算法。<br />
2.最短作业优先(<code>SJF, Shortest Job First</code>)调度：实质-根据最短的下次<code>CPU</code>执行时间进行调度；最优算法，给定进程的平均等待时间最小；难以知道下次<code>CPU</code>执行的长度，可通过以前<code>CPU</code>执行测量长度的指数平均进行预测(<span class="arithmatex">\(\tau_{n + 1} = \alpha t_n + (1 - \alpha) \tau_n\)</span>)；可以是非抢占式调度，也可以是抢占式调度（此时，实质为最短剩余时间优先调度）。<br />
3.优先级调度：可以是抢占式，也可以是非抢占式；问题-无穷阻塞、饥饿，低优先级进程可能产生无穷等待；解决方法-<code>(priority) aging</code>，即逐渐增加在系统中等待时间很久的进程的优先级。<br />
4.轮转(<code>RR, Round-Robin</code>)调度：为分时系统设计；抢占式调度策略；就绪队列为<code>FIFO</code>队列；定义时间片(<code>time quantum</code>)，循环扫描就绪队列，为每个进程分配不超过一个时间片的<code>CPU</code>；平均等待时间一般比<code>SJF</code>调度算法差，但是没有饥饿问题，响应时间有所改善；有界等待。  <br />
5.多级队列(<code>Multilevel Queues</code>)调度：各队列优先级不同；队列内部分别采取不同的调度算法；队列间既可以进行抢占式优先级调度，也可以进行时间的划分；应对前台进程（交互进程）、后台进程（批处理进程）对响应时间的不同要求；进程永久分配到一个特定的队列。<br />
6.多级反馈队列(<code>Multilevel Feedback Queues</code>)调度：进程可在不同队列之间移动；若<code>CPU</code>使用时间过多，则优先级下降，将<code>I/O</code>密集型进程、交互进程放到更高优先级队列；使用<code>(priority) aging</code>，防止进程饥饿问题发生。<br />
7.进程调度算法的评估：理论/分析结果-不易获得；仿真-精确度有限；实现-唯一的完全精确方式。<br />
<strong>三、线程调度</strong><br />
1.竞争范围(<code>Contention Scope</code>)<br />
·用户级线程-进程竞争范围(<code>PCS, Process Contention Scope</code>)：同一进程的线程之间竞争<code>CPU</code>；一般采用优先级调度。<br />
·内核级线程-系统竞争范围(<code>SCS, System Contention Scope</code>)：内核级线程与系统内所有线程进程<code>CPU</code>。<br />
·采用一对一模型的操作系统，只采用系统竞争范围(<code>SCS</code>)调度。<br />
2.多处理器调度<br />
·多处理器：多核<code>CPU</code>、多线程核（若某线程阻塞，则直接切换到另一线程）<br />
·非对称多处理(<code>Asymmetric Multiprocessing</code>)：一个处理器（主服务器）处理所有调度决定、<code>I/O</code>和其他系统活动，其余处理器只执行用户代码。<br />
·对称多处理(<code>Symmetric Multiprocessing, SMP</code>)：各处理器自我调度。可以所有进程处于共同就绪队列，也可以每个处理器拥有自己的私有就绪队列。<br />
3.多线程多核系统：二级调度-操作系统决定哪一个软件线程应该运行于逻辑<code>CPU</code>-&gt;每个内核决定使用哪个硬件线程在物理内核上运行。<br />
4.处理器亲和性(<code>processor affinity</code>)：软亲和性(<code>soft affinity</code>)-操作系统试图保持进程运行在同一处理器上，但不保证；硬亲和性(<code>hard affinity</code>)：保证某进程运行在同一个处理器子集上。<br />
5.负载平衡：设法将负载平均分配到<code>SMP</code>系统的所有处理器；推迁移-特定任务周期性检查每个处理器的负载，若发现不平衡，则将进程推到空闲或不太忙的处理器；拉迁移-空闲处理器从忙处理器上拉一个等待任务时，发生拉迁移。<br />
6.多线程的粒度：粗粒度(<code>coarse-grained</code>)多线程：线程一直在处理器上执行，知道一个长延迟事件发生；细粒度(<code>fine-grained</code>)多线程：在指令周期的边界上切换线程。 <br />
7.实时<code>CPU</code>调度<br />
（1）最小化延迟：事件延迟(<code>event latency</code>)-从事件发生到事件得到服务的时间；中断延迟-<code>CPU</code>从收到中断，到中断处理程序开始所需的时间；调度延迟：调度程序从停止一个进程，到启动另一个进程所需的时间。<br />
（2）优先级调度：硬实时系统应保证实时任务在截止期限内得到服务，可利用进程截止期限/速率（周期的倒数）分配优先级；准入控制（<code>admission control</code>），接收进程任务，保证完成，若不能保证在截止期限前完成服务，则拒绝请求。<br />
（3）单调速率调度：抢占式调度、静态（固定）优先级；速率为周期的倒数，周期越短，速率越高；是最优调度，若一组进程不能由该算法调度，则不能由其他分配静态优先级的算法进行调度；调度<span class="arithmatex">\(N\)</span>个进程，最坏<code>CPU</code>利用率为<span class="arithmatex">\(N(2^{\frac{1}{N}} - 1)\)</span>。<br />
（4）最早截止期限优先调度：截止期限越早，优先级越高；进程向系统公布截止期限要求；截止期限及优先级可以动态调整。<br />
（5）比例分享调度：按比例给程序分配<code>CPU</code>时间；采取准入控制，请求<code>CPU</code>时间股数小于可用股数才允许用户进入。<br />
<strong>四、调度算法评估</strong><br />
1.评估准则：最大化<code>CPU</code>利用率；限制最大响应时间；最大化吞吐量。<br />
2.评估方法：确定型模型-采用特定的预先确定的负荷，计算给定负荷下每个算法的性能；排队模型、排队网络分析-根据<code>CPU</code>执行的分布、进程到达系统时间的分布，计算平均吞吐量、<code>CPU</code>利用率、等待时间；<code>Little</code>公式-<span class="arithmatex">\(n = \lambda W\)</span>，<span class="arithmatex">\(n\)</span>为平均队列长度，<span class="arithmatex">\(W\)</span>为队列的平均等待时间，<span class="arithmatex">\(\lambda\)</span>为新进程到达队列的平均到达率；仿真；实现。  <br />
<strong>第六章 同步</strong><br />
<strong>一、同步基本概念</strong><br />
1.背景：进程/线程并发执行时，可能在任意时刻被打断，一些操作可能只是部分完成；共享数据的并发访问可能导致数据不一致性。<br />
2.竞争条件(<code>race condition</code>)：多个进程并发访问相同数据，执行结果依赖于访问发生的顺序。<br />
3.临界区问题<br />
（1）组成：进入区、临界区、退出区、剩余区。 
<img alt="" src="../assets/OSFinal/9.JPG" /><br />
（2）临界区问题解决方案的要求：互斥(<code>mutual exclusion</code>，若某进程在临界区内执行，则其余进程均不能在该临界区内执行)、空闲让进(<code>progress</code>，若无进程在临界区执行，且有进程需要进入临界区，则只有不在剩余区的进程可被选择进入临界区，且这种选择不可无限推迟)、有限等待(<code>bounded waiting</code>，进程发出进入临界区到请求被允许位置，其余进程允许进入该临界区的次数具有上限)。<br />
4.处理临界区问题的内核分类：抢占式内核-允许<strong>内核模式线程</strong>被抢占；非抢占式内核：不允许<strong>内核模式线程</strong>被抢占。<br />
<strong>二、<code>Peterson</code>解决方案</strong><br />
1.目的：解决两个进程/线程之间的同步问题。<br />
2.方法：使用原子的<code>Load/Store</code>操作。<br />
3.变量设置：<code>bool flag[2]</code>，为真表示相应进程准备进入临界区；<code>int turn</code>，表明哪个进程可以进入临界区。<br />
<img alt="" src="../assets/OSFinal/10.JPG" /><br />
4.理解：互斥-<code>P0</code>进入临界区前，将<code>flag[0]</code>设置为真，且等到<code>turn = 0</code>时才能进入临界区，通过对<code>flag[1], turn</code>取值的讨论可以验证互斥条件；空闲让进-进程退出临界区时，通过<code>flag[i] = FALSE</code>的设置，允许另一进程进入临界区；有限等待：某进程退出临界区时，设置<code>flag[i] = FALSE</code>，如果另一进程作出了进入临界区请求，最多等待进程<code>i</code>进入一次临界区后，另一进程就可以进入临界区了。<br />
5.改进：处理器对不存在数据以来的操作进行重新排序，以提升性能。<br />
6.缺点：只对两个进程的同步问题有效；需保证<code>LOAD, STORE</code>是原子操作；操作的重新排序可能导致运行结果改变。<br />
<strong>三、进程同步的硬件支持</strong><br />
1.单一处理器：禁用中断。<br />
2.常见解决方法：内存屏障、硬件指令(<code>test-and-set, compare-and-swap</code>)、原子变量。<br />
3.内存屏障：<code>strongly ordered</code>，表明某处理器所作的内存修改对其余处理器立即可见；<code>weakly ordered</code>，表明某处理器所作的内存修改对其余处理器不是立即可见的；内存屏障：指令如果修改内存，就必须对所有处理器立即可见。<br />
4.硬件指令：<code>test-and-set</code>指令：原子地返回某个变量的原有数值，并将其设置为<code>1</code>；<code>compare-and-swap</code>：比较变量的原有数值跟期望数值是否相同，若相同，则变量被更新为新的数值；使用<code>compare_and_swap</code>实现锁与互斥访问-直到锁的旧值变为<code>0</code>，进程才结束忙等待，进入临界区；退出临界区时，进程释放锁。 <br />
<img alt="" src="../assets/OSFinal/13.JPG" /><br />
（4）使用<code>test_and_set</code>实现有界等待互斥访问：首先，直到<code>lock</code>的旧值为<code>0</code>，即用锁的进程将锁释放，或者<code>waiting[i] = false</code>，当前进程才能结束忙等待，获取锁；然后，进入临界区；最后，进程退出临界区时，按照循环队列的逻辑顺序，向后查找第一个需要进入临界区的进程。如果能找到，则设置<code>waiting[j] = false</code>，令该进程获取锁；否则，令<code>lock = false</code>，之后某个进程再需要锁时，将其置为<code>true</code>即可。  <br />
<img alt="" src="../assets/OSFinal/12.JPG" /><br />
<img alt="" src="../assets/OSFinal/14.JPG" /><br />
（5）使用<code>compare_and_swap</code>实现原子递增操作<br />
<strong>四、互斥锁与信号量</strong><br />
1.互斥锁：保护临界区，使其只能互斥访问；缺点是忙等待，其余进程进入临界区，必须连续不断地调用<code>acquire()</code>系统调用，浪费<code>CPU</code>周期；又称自旋锁(<code>spinlock</code>)，进程不断旋转以等待锁可用。  <br />
2.信号量：初始化后只能由<code>wait/P, signal/V</code>操作进行访问；<code>wait</code>与进程阻塞：先让<code>signal</code>的值减一，若减一后，信号量值小于<code>0</code>，表示当前进程无法获得信号量，进入阻塞状态，同时进入信号量等待队列中；<code>signal</code>与进程唤醒：先让<code>signal</code>的值加一。若加一后，信号量值不是整数，则说明信号量等待队列非空，从中移除一个进程，并将之唤醒。<br />
<img alt="" src="../assets/OSFinal/15.JPG" /><br />
·优点：进程的阻塞与唤醒操作，解决了忙等待问题，节省了<code>CPU</code>时间。<br />
3.对比——互斥锁（自旋锁）与信号量：互斥锁-优点是无需阻塞进程；缺点是忙等待；使用于较短临界区；信号量-好处是无需忙等待；缺点是进程阻塞、上下文切换浪费时间；适用于较长临界区。<br />
4.死锁与饥饿问题：死锁-两个或多个进程同时无限等待只能由它们之中一个进程触发的事件；饥饿-进程可能永远无法从信号量的等待队列中移除，等待时间无限长。<br />
5.优先级逆转问题：高优先级进程被低优先级进程间接抢占。<br />
·举例：低优先级进程持有锁，但是由于优先级低难以获得<code>CPU</code>时间；高优先级进程等待锁的释放。若此时一个中优先级进程无需等待进程，直接就绪、运行，则对高优先级进程进行了间接抢占。<br />
·解决方法：优先级继承，暂时令持有锁的进程具有等待锁的进程的优先级，锁释放后优先级恢复原状。<br />
<strong>五、同步经典案例一——有界缓冲问题(<code>bounded-buffer problem</code>)</strong><br />
1.问题描述：生产者进程、消费者进程、<code>n</code>个共享缓冲块；生产者向缓冲块中生产数据，消费者从缓冲块中取出数据并移除。  <br />
2.基本目的：若缓冲块满，则生产者不再生产新数据；若缓冲块为空，则消费者不会再尝试从缓冲块中移除数据。<br />
3.信号量设计：互斥锁信号量，初始化为<code>1</code>；满槽数信号量，初始化为<code>0</code>；空槽数信号量，初始化为<code>n</code>。<br />
4.生产者、消费者进程实现：生产者进程-先等待空槽信号量，再等待互斥锁；完成生产后，先释放互斥锁，再释放满槽信号量-消费者进程：先等待满槽信号量，再等待互斥锁；完成消费后，先释放互斥锁，再释放空槽信号量。<br />
<img alt="" src="../assets/OSFinal/16.JPG" /><br />
<img alt="" src="../assets/OSFinal/17.JPG" /> <br />
<strong>二、同步经典案例二——读者-写者问题</strong><br />
1.问题描述：某数据集被多个并发进程共享，读者只能读不能写，写者可读可写；共享访问是指，允许多个读者同时读取数据；互斥访问是指，只允许一个写者访问数据。<br />
2.信号量设计：互斥锁信号量，初始化为<code>1</code>；写信号量，初始化为<code>1</code>；读者数量整形变量，初始化为<code>0</code>。<br />
3.写者进程实现：只需等待写信号，获得写信号后对共享数据进行写入操作即可。<br />
<img alt="" src="../assets/OSFinal/18.JPG" /><br />
<img alt="" src="../assets/OSFinal/19.JPG" /><br />
4.读者进程实现：注意到普通整形变量<code>readcount</code>的更新需要互斥锁，否则，<code>readcount</code>可能产生数据不一致问题；若当前进程是唯一一个有读取需求的读者进程，则需等待<code>write</code>写锁，一方面是确保没有写者进程正在写入，另一方面是确保子集开始读取进程后，写入操作暂时被禁止；完成读操作，调用互斥锁更新<code>readcount</code>变量，若无读者则需释放<code>write</code>写锁。<br />
5.问题变形：读者优先（上述案例）、写者优先（再加一个<code>write</code>信号量，写者先请求<code>write</code>再作正常读写锁获取，读者获取读权限、更新<code>readcount</code>时拿<code>write</code>，一获得读权限但还未正式进临界区就释放<code>write</code>）。<br />
<strong>三、同步经典案例三——哲学家就餐问题</strong><br />
1.问题描述：哲学家坐在圆桌前，仅有就餐、思考两种状态；每两个哲学家之间有一根筷子；哲学家一次性只能拿一根筷子；哲学家拿起两根筷子开始就餐，就餐结束后放下两根筷子。该问题代表了多种资源分配下的并发控制问题。<br />
2.解决方案：信号量<code>chopsticks[5]</code>，均初始化为<code>1</code>。<br />
3.问题：每个哲学家先等待左侧筷子，再等待右侧筷子，会导致死锁问题；给每个筷子添加一个互斥锁，不会解决死锁问题。  <br />
4.非对称解决方案：若奇数序号的哲学家先拿左手边的筷子，偶数序号的哲学家先拿右手边的筷子，则不会导致死锁。<br />
<strong>第七章 死锁</strong><br />
<strong>一、基本概念</strong><br />
1.死锁：一组阻塞进程，每个进程持有一个资源，并等待获得一个被组中另一进程持有的资源。<br />
2.死锁解决时，可能进行资源抢占和回滚；可能产生饥饿问题。<br />
3.死锁模型：资源<span class="arithmatex">\(R_1, \cdots, R_m\)</span>；各资源类型的实例个数<span class="arithmatex">\(w_i\)</span>；进程对资源的利用，分为请求、使用、释放三个阶段。<br />
4.死锁产生的四个条件：互斥(<code>mutual exclusion</code>)、占有并等待(<code>hold and wait</code>)、非抢占(<code>no preemption</code>)、循环等待(<code>circular wait</code>)。<br />
5.资源分配图：由进程节点、资源节点、请求边（进程-&gt;资源）、分配边（资源-&gt;进程）。<br />
6.环形等待与死锁：若无环形等待，则必定无死锁；若有环形等待，如果图中每类资源只有一个实例，则可判断产生死锁，若每类资源的实例多于一个，则死锁有可能会发生。<br />
<strong>二、死锁的解决方法</strong><br />
1.四类死锁解决方法：死锁预防、死锁避免、死锁检测、死锁恢复。<br />
2.死锁预防：只需破坏死锁产生的四个条件之一，则死锁解除。<br />
·<code>hold and wait</code>：进程执行前，一次性获得所有资源，中途不能再申请；或进程释放已有资源后，才能获得其他资源。<br />
·<code>no preemption</code>：允许资源抢占，被抢占资源的进程重新进入等待状态，直至所有资源就绪，该进程再重启。<br />
·<code>circular wait</code>：对资源进行一次完全排序(<code>total ordering</code>)，进程只能按照序号递增的顺序获取资源。<br />
3.死锁避免：需要进程按照怎样顺序申请、如何申请资源的额外信息；系统作决策时，综合考虑现有可用资源、现已分配给每个进程的资源和每个进程将来申请和释放的资源；保证死锁永不发生；安全状态-存在进程序列，对每个进程<span class="arithmatex">\(P_i\)</span>，它额外请求的资源可被现有可用资源 + 前序进程资源满足，则称现有的资源分配状态是安全的；安全状态保证无死锁发生，不安全状态下可能发生死锁；一般按照额外需求的资源数量由少到多的顺序，判断是否为安全状态。<br />
·单一资源死锁避免：使用资源分配图，边的转化情况为：<code>claim edge-&gt;request edge-&gt;assignment edge-&gt;claim edge-&gt;...</code>，图中无环则保证了安全状态。<br />
·多种资源死锁避免：使用银行家算法，每个进程必须提前声明需要使用每类资源的最大数量，进程请求资源时必须等待，若进程获得了所有资源则必须在优先时间内释放这些资源，数据结构有<code>need[i, j], max[i, j], allocation[i, j], available[j]</code>；右上角表示现有剩余资源，按照仍然需求的资源不超过现有可用资源的顺序，不断进行资源分配和释放，每个进程释放资源后，现有可用资源会上升。<br />
4.死锁检测：允许系统进入死锁状态，检测死锁并恢复。<br />
·每类资源只有一个实例的死锁检测：可采用等待图，由进程作为节点，边<span class="arithmatex">\(P_i\rarr P_j\)</span>表示进程<span class="arithmatex">\(P_i\)</span>等待进程<span class="arithmatex">\(P_j\)</span>，周期性检查等待图是否存在环路，存在环路表示存在死锁。<br />
·每类资源有多个实例的死锁检测：类似银行家算法，按照进程请求资源不超过现有可用资源的顺序，检测进程序列，判断是否有死锁。左图无死锁，右图有。<br />
<strong>第八章 内存管理策略</strong><br />
<strong>一、基本概念</strong><br />
1.进程地址空间保护：使用基地址寄存器（<code>base register</code>，指定最小的合法物理地址）、界限寄存器（<code>limit register</code>，指定进程占有内存范围的大小）。<br />
2.地址绑定：将程序中的符号地址绑定到可重定位的地址；编译时绑定-编译时知道进程在内存中驻留的绝对地址，则可进行编译时绑定，生成绝对代码；若起始地址发生变化，则进程代码需要重新编译；加载时绑定-编译时不知道进程将驻留在何处，则编译器生成可重定位代码，绑定延迟到加载时才执行；起始地址发生变化，只需重新加载用户代码即可；执行时绑定-进程在执行时可从一个内存段移动到另一个内存段，则绑定延迟到执行时才进行；为大多数通用计算机操作系统所采用。<br />
3.逻辑地址与物理地址：逻辑地址-<code>CPU</code>生成的地址；物理地址：内存单元看到的地址（加载到内存地址寄存器的地址）。 <br />
3.内存管理单元（<code>MMU, Memory Management Unit</code>）：完成虚拟地址到物理地址的运行时映射；<code>base</code>寄存器又称重定位寄存器，逻辑地址 + 重定位寄存器 = 虚拟地址。<br />
4.动态加载：子程序以可重定位的方式保存在磁盘上，只有被调用时，才被加载到内存中。<br />
5.动态链接：链接延迟到运行时；库程序引用存根(<code>stub</code>)表明如何定位适当的内存驻留库程序，或程序不在内存中时，应如何加载到内存中。<br />
6.交换：进程暂时从内存换出，之后再换入内存。<code>roll out and roll in</code>表示更高优先级进程需要服务时，内存换出低优先级进程，以转载、执行高优先级进程；高优先级进程执行完毕后，再换回低优先级进程。<br />
<strong>二、连续内存分配</strong><br />
1.内存分为两个区域：驻留操作系统、驻留用户进程。<br />
2.内存保护：通过重定位寄存器+界限寄存器实现。<br />
3.内存分配：多分区(<code>multiple-partition</code>)方法-内存划分为多个物理连续的分区，每个分区仅包含一个进程：可变分区(<code>variable-partition</code>)方法-操作系统维护表，记录哪些内存可用、哪些内存已用；一段可用内存称为一个<code>hole</code>，经若干次分配和释放后，可用内存集合即不同大小的<code>hole</code>的集合。<br />
·动态分配存储问题的常见方法（选择<code>hole</code>的方法）：<code>First Fit, Best Fit, Worst Fit</code>。一般<code>First Fit, Best Fit</code>执行时间、空间利用率都更好一些，<code>First Fit</code>比<code>Best Fit</code>更快。<br />
4.内存碎片：外部碎片-空闲内存空间被分为小的片段，若总的可用内存之和可以满足请求，但可用内存并不连续，则产生外部碎片问题；内部碎片-进程分配到的内存大于实际所需的内存；外部碎片的解决方法-紧缩(<code>compaction</code>)，即移动内存内容，使得空闲空间合并为一整块。<br />
<strong>三、分段与分页</strong><br />
1.分段：段表、段基地址、段界限；逻辑地址由<code>&lt;segmentation number, offset&gt;</code>组成。<br />
2.分页：允许进程内存的不连续分配，避免外部碎片、紧缩，但存在内部碎片；<code>CPU</code>生成的逻辑地址由<code>&lt;page number, offset&gt;</code>组成；页大小为<code>2</code>的幂。<br />
3.<code>TLB(translation look-aside buffer)</code>：若<code>buffer</code>中存在某页的地址转换信息，则无需访问内存中的页表，提高效率；若页码不在<code>TLB</code>中，则需选一个<code>TLB entry</code>进行替换；使用<code>associative memory</code>，支持并行搜索。  <br />
4.内存访问时间：内存访问时，若未命中，则需先访问页表对应的内存，再访问目的内存，使得内存访问开销翻倍。<br />
5.页面共享：可用于共享库；一份代码可以同一程序的所有进程共享（如：文本编辑器、编译器、浏览器）；共享内存，用于<code>IPC(Inter-Process Communication)</code>。<br />
6.页表结构：页表需要物理连续；可分为一、二、三级页表。<br />
<img alt="" src="../assets/OSFinal/28.JPG" /> <br />
7.哈希页表：哈希表每一个表项都是链表；查表时，虚拟页号哈希映射到相应表项，与链表节点的虚拟页号进行逐个比较，相等节点对应的物理地址即为所需。<br />
8.反向页表：每个物理帧对应一个表项；页表占据的内存空间是固定的；每个表项存储进程序号、物理页对应的虚拟页号。<br />
<strong>第九章 虚拟内存管理</strong><br />
<strong>一、知识点</strong><br />
1.虚拟内存允许进程共享内存（如：共享库），提升进程间通信<code>IPC</code>的性能。<br />
2.允许<code>fork</code>系统调用采用写时复制。<br />
3.<code>MMU(Memory Management Unit)</code>产生<code>page fault</code>。<br />
4.<code>page fault</code>交换器：懒交换器(<code>lazy swapper</code>)，直到页面真正需要再换入内存；预调页，利用空间局部性调入访问页面之后的一些相邻页面。<br />
5.内存有效访问时间(<code>effective access time, EAT</code>) = <code>1 - p</code>×内存访问时间 + <code>p</code>×（<code>page fault</code>处理开销 + 页面换出开销 + 指令重新启动的开销）<br />
6.交换<code>I/O</code>快于文件系统<code>I/O</code>，因此可以在加载进程时，将整个进程从磁盘复制到交换空间，以提升性能。<br />
7.页面置换算法：<code>FIFO</code>有<code>Belady's Anomaly</code>异常；最优算法替换的是最远的未来才被用到，或不再被用到的块，需要未来块的使用信息；<code>LRU</code>的准确实现可以基于栈、计数器，用<code>reference bit</code>周期性逻辑右移、访问时升高最高位近似实现。<br />
8.第二次机会算法：<code>FIFO + reference bit</code>，时钟替换算法。若<code>reference bit = 0</code>，直接替换；若<code>reference bit = 1</code>，将其清零，并找到下一个页进行替换。<br />
9.增强第二次机会算法：使用<code>reference bit + modify bit</code>，优先级从低到高<code>(0, 0)-&gt;(0, 1)-&gt;(1, 0)-&gt;(1, 1)</code>，优先级越低则越可能被替换；时钟替换算法。<br />
10.基于计数的页面替换：<code>LFU(Least Frequently Used)/MFU(Most Frequently Used)</code>。<br />
11.<code>page buffereing</code>算法：保存空闲帧列表、修改页列表；不清除页中的内容，而是记录它们最近包含的是什么内容，如果相应页再次被访问，可以直接使用该页而无需从内存中加载。<br />
12.双缓冲问题：浪费内存空间，操作系统、应用分别保留一份页，分别用于作为<code>I/O</code>缓冲区、用于应用进程自身的任务。<code>I/O</code>密集型应用可能导致双缓冲问题。<br />
13.帧分配：平等分配、比例分配；帧替换：全局替换（更高吞吐量；进程执行时间可能差别较大）、局部替换（更一直的逐进程性能，但是内存可能利用不充分）。<br />
14.页面回收(<code>reclaim page</code>)：空闲页比例低于阈值即开始回收页面，保证有足够的空闲内存，以满足新的页面请求。<br />
15.<code>major page fault</code>：页只能在磁盘中找到；<code>minor page fault</code>，页在内存中，但是映射关系没有建立，可能是共享库，也可能是页被回收但还未清零。<br />
16.<code>Non-Uniform Memory Access, NUMA</code>，分配离<code>CPU</code>更近的内存可以提高性能。<br />
17.颠簸(<code>Thrashing</code>)进程不断换进、换出页面，原因是：进程的总内存大小小于进程局部的大小；解决方法有：使用局部页面替换而非全局页面替换，使用工作集记录最近<code>m</code>次访问的页面，这些页面不会被换出。<br />
18.工作集窗口大小为<code>k</code>表示：最近<code>k</code>次访问的页面（可能重复）在工作集中。<br />
19.部分内核内存有物理连续的需求，如设备<code>I/O</code>等。<br />
20.<code>TLB reach = TLB size * page size</code>；通过增大页面大小可以降低<code>TLB</code>压力。<br />
21.<code>I/O</code>联锁(<code>I/O Interlock</code>)：用于从设备中复制文件的内存页应被加锁，防止被替换。<br />
22.<code>slab</code>分配器：一组对象的缓冲区，一个<code>cache</code>包含一个或多个<code>slab</code>，一个<code>slab</code>有一个或多个页，被分割为等大的对象；好处是没有<code>fragmentation</code>、快速内存分配。<br />
<strong>第十章 文件系统接口</strong><br />
<strong>一、知识点</strong><br />
1.打开文件：进程打开文件表、全局打开文件表（每个文件只有一个表项，用引用计数表明有多少个进程打开该文件）。<br />
2.锁：强制锁、建议锁。<br />
3.访问：顺序访问、随机访问（直接访问）。<br />
4.磁盘：可以分为分区(<code>partitions/minidisks/slices</code>)。<br />
5.目录：一级、二级(<code>Master File Directory, MFD; User File Directory, UFD</code>)、树结构（文件分组、命名方便、搜索高效）、无环图结构（允许链接到其他的目录、文件，用于起别名；使用向后指针、引用指针）。<br />
6.硬连接：使用引用计数，用户文件目录包含的是索引节点的指针，引用计数为<code>0</code>才真正删文件，用户一般删除的只是自己的目录项。<br />
7.软连接：主文件才有指向文件索引节点的指针，其他用户都只有该文件的路径名，没有指向索引节点的指针。<br />
8.一般图目录：允许任意连接，可能产生环路；解决环路问题，可以通过垃圾回收对磁盘空间进行回收，也可以在新链接创建时，使用环路检测算法判断合法性。<br />
10.文件系统加载：把文件系统链接到操作系统中，形成一个单一命名空间(<code>single name space</code>)；装载点的旧目录之后不可见。<br />
11.文件系统共享：保护模式，如<code>User ID, Group ID</code>；分布式系统，通过<code>NFS, Network File System</code>进行共享，用客户-服务器模式，允许用户从服务器装载文件系统。<br />
12.<code>ACL, Access Control List</code>，细粒度控制。<br />
<strong>第十一章 文件系统实现</strong><br />
<strong>一、知识点</strong><br />
1.文件系统的层次化：应用程序-&gt;逻辑文件系统（保存文件系统元信息，存储目录结构，保存文件控制块<code>FCB</code>，输入读写目录，输出逻辑块）-&gt;文件组织模块（将逻辑文件块映射到物理文件块，管理空闲空间）-&gt;基本文件系统（分配、维护包含文件系统、目录、数据块的缓冲区，缓冲区作为<code>cache</code>增强性能）-&gt;<code>I/O</code>控制（包含：设备驱动器、中断处理器）。<br />
2.层次化文件系统降低了复杂度，但是增加了额外开销，导致性能下降。<br />
3.磁盘文件结构：启动控制块、卷控制块（包含卷中的块数、空闲块指针、空闲<code>FCB</code>数量及指针等）、目录、<code>FCB</code>。<br />
4.内存文件结构：装载表，一个表项对应于一个装载的卷；目录<code>cache</code>，用于快速的路径映射；全局打开文件表、进程打开文件表；各类<code>buffer</code>，包含在传输的磁盘块。<br />
5.装载文件时，只先把<code>FCB</code>加载到内存，并添加到系统级别的打开文件表，真正需要访问文件数据时，再将文件数据块加载到内存中。<br />
6.虚拟文件系统：面向对象；把文件基本操作和实现细节隔离开，使操作系统可以处理不同的文件系统。<br />
7.目录实现：哈希表；线性表，对于每个文件名，包含指向文件元信息的指针，时间开销大。<br />
8.磁盘文件块分配：连续分配（对顺序访问友好，降低<code>seek time</code>，目录只需追踪其头部块地址、在块中的长度即可；难以寻找空闲空间，产生外部碎片，可扩展性差）；链接分配（一个块包含到下一个块的指针，块可离散分布；定位某一个块，需要大量的<code>I/O</code>和<code>disk seek</code>；可通过将块聚合成簇进行改进，但是又会产生内部碎片）、索引分配（无外部碎片，支持顺序访问和直接/随机访问；由索引块产生额外开销；可以使用多级索引块、链式索引块；索引节点称为<code>inode(index node)</code>）。<br />
9.<code>FAT(Fie Allocation Table)</code>。<br />
10.磁盘空闲空间管理：<code>bitmap</code>；空闲块之间形成链接；使用索引对空闲块分组，并计数。<br />
11.提升文件系统性能：异步写（<code>buffered/cached</code>）、延迟释放和提前读取。<br />
12.<code>page cache</code>：可用于内存映射文件；文件系统使用<code>buffer(disk) cache</code>，用于磁盘<code>I/O</code>。<br />
13.文件系统需保证一致性；故障恢复方法包括备份、日志等。<br />
<strong>第十二章 大容量存储介质</strong><br />
<strong>一、磁盘结构</strong><br />
1.寻址：相当于访问逻辑块构成的一维数组，逻辑块是最小的传输单元。<br />
2.逻辑块被映射到磁盘的扇区(<code>sector</code>)，从最外侧到最内侧磁道(<code>track</code>)，扇区号逐渐增加；首先在当前磁道进行映射，然后映射同轴圆柱体的其他磁道；最后在从外向内映射其余同轴圆柱上的磁道。<br />
3.<code>positioning time(random access time) = seek time + rotational latency</code>，其中<code>seek time</code>移动到指定的圆柱，<code>rotaitional latency</code>移动到目标扇区。<br />
4.性能评价：有效/理论数据传输率、<code>seek time</code>、<code>latency</code>。<br />
5.<code>average I/O time = average access time + (data to transfer / transfer rate) + controller overhead</code>。<br />
<strong>二、磁盘调度</strong> <br />
1.操作系统进行好的磁盘调度，应尽量优化磁盘的<code>access time</code>(<code>seek time + rotational latency</code>)和<code>disk bandwidth</code>(由数据传输量、从第一个请求发出到最后一个传输完成的时间决定)。<br />
2.磁盘调度：决定哪个等待的磁盘请求先进行服务；尽量最小化<code>seek time</code>，而操作系统一般难以计算<code>rotational latency</code>。<br />
3.<code>FCFS</code>算法：请求获得服务的机会公平，没有无限推迟问题；但是并不尝试优化<code>seek time</code>，从而服务质量也不是最佳。<br />
4.<code>SSTF</code>算法：减少平均等待时间，增大吞吐量；可能不是最优算法；较长<code>seek time</code>的请求可能遭遇饥饿问题；提前计算<code>seek time</code>带来开销；响应时间方差较大，表明<code>SSTF</code>算法只青睐某一部分请求。<br />
5.<code>SCAN</code>算法：高带宽，响应时间方差小；但是刚被磁盘臂访问过的位置若有请求，则请求的等待时间较长。<br />
6.<code>C-SCAN</code>算法：与<code>SCAN</code>算法相比，响应时间更为均匀。<br />
7.<code>LOOK/C-LOOK</code>：防止了必须移动到磁盘某一段而带来的额外延迟。<br />
8.算法选择：<code>SSTF</code>常用，适合作为默认调度算法；<code>LOOK/C-LOOK</code>在<code>I/O</code>负载较重的情况下表现较好。<br />
9.文件分配、元数据的分布，都会影响磁盘的性能，原因是文件系统耗费大量努力，以提升空间局部性。<br />
<strong>三、非易失性存储介质</strong><br />
1.<code>SSD</code>、<code>USB drives</code>等，比<code>HDD</code>更可靠，更昂贵，寿命更短；容量更少，但是速度快许多；总线可能速度太慢；没有移动部件，没有<code>seek time, rotational latency</code>，因此<code>FCFS</code>算法是较好的选择。<br />
2.挑战性：必须首先擦除然后重写，以更大的块，而不是页为单位；总擦除次数、每日擦除次数均有上限。<br />
3.<code>NAND Flash</code>控制器算法<br />
4.磁带<br />
<strong>四、磁盘管理</strong><br />
1.物理格式化/低级格式化：将磁盘分为扇区，供磁盘控制器读写；扇区可以包含头信息、数据、错误纠正码(<code>error correction code, ECC</code>)。<br />
2.操作系统将自己的数据结构放在磁盘上，将磁盘分为由圆柱面形成的组，每个组视为一个逻辑块。<br />
3.逻辑格式化：操作系统将文件系统的初始数据结构放在磁盘上，数据结构记录了空闲空间、已分配空间，还包含一个初始为空的目录；一些文件系统有空闲块，以处理坏块；不同的块可以组合成一个簇(<code>cluster</code>)，以进一步提升性能。<br />
4.磁盘<code>I/O</code>以块为单位进行操作；文件<code>I/O</code>以簇为单位进行操作。<br />
5.<code>bootstrap</code>程序：位于<code>ROM</code>中，规模较小，作用是从磁盘调入完整的引导程序；完整引导程序存储在磁盘固定位置上的“启动块”，该磁盘称为启动磁盘。<br />
6.坏块处理：扇区备用(<code>sector sparing/sector forwarding</code>)、扇区滑动(<code>sector slipping</code>)。<br />
7.磁盘分区(<code>partition</code>)：根分区包含操作系统，在启动时装载到内存；其余分区可以自动装载、手动装载。<br />
·装载时，检验文件的一致性，分析是否所有元数据都正确，如不正确应尝试修复。<br />
·引导块：指向完整的文件系统引导代码区。<br />
<strong>五、交换空间管理</strong><br />
1.作用：用于进程切换、页面切换，当<code>DRAM</code>不足以支撑所有进程运行时，将一部分进程、页面从<code>DRAM</code>移动到辅助存储设备。<br />
2.交换空间管理：多个交换空间，以降低设备的<code>I/O</code>负载；独占设备是较好的选择；可以位于不同的扇区，也可以是文件系统的一个文件。<br />
3.磁盘连接：主机连接的存储（由<code>I/O</code>总线直连）、网络连接的存储（常用协议：<code>NFS, CIFS, iSCSI</code>；通过远程函数调用(<code>Remote Procedure Call</code>)实现）、存储空间网络(<code>Storage Area Network, SAN</code>，连接服务器、存储单元的私有网络，使用告诉连接、高效的协议)。<br />
<strong>六、<code>RAID(Redundant Arrays of Independent Disks)</code></strong><br />
1.磁盘不可靠、速度慢，但是便宜；该方案的作用是提高可靠性和磁盘访问速度（若数据跨磁盘分布，则可以提高数据读写的带宽）。<br />
2.<code>RAID</code>的常用手段：数据镜像(<code>Data Mirroring</code>)，将同样的数据复制到多个磁盘上，每次写数据，每个镜像都要写一遍；数据分条：将数据分割到不同的磁盘上，以允许并行读取；错误纠正码(<code>Error-Code Correcting, ECC</code>)，使用奇偶校验位等措施，以重构损失的位。<br />
3.<code>RAID</code>级别：<code>RAID 0</code>，数据分条存放在不同的磁盘上，一般分条大小固定，可以提高性能，但可靠性未提高，用于高性能场景；<code>RAID 1</code>，一组数据镜像复制到两个磁盘上，每次写数据，两个镜像都要写；<code>RAID 2</code>，比特级别数据分条，使用<code>Hamming Code</code>用于错误纠正(<code>4 bits data + 3 bits parity</code>)；<code>RAID 3</code>，比特级别数据分条(<code>bit-interleaved parity</code>)，一个磁盘专门存放奇偶校验信息；<code>RAID 4</code>，块级数据分条，专用奇偶校验盘，小型读取只涉及一个磁盘；<code>RAID 5</code>，块级数据分条，奇偶校验分布在所有磁盘上；<code>RAID 6</code>，对<code>RAID 5</code>添加了一重额外的校验（双重校验）。<br />
4.<code>RAID</code>与文件系统：只能从磁盘故障中进行错误的检测与恢复，不解决数据损坏(<code>data corruption</code>)等问题。<br />
<strong>第十三章 <code>I/O</code>系统</strong><br />
<strong>一、基本概念</strong><br />
1.<code>I/O</code>的必要设备：总线、端口、控制器。<br />
2.<code>I/O</code>访问的方式：轮询(<code>polling</code>)、中断。<br />
3.<code>I/O</code>设备的寄存器：设备通常提供寄存器，用于<code>I/O</code>设备的数据传输与控制，包含数据流入/流出、状态、控制/命令寄存器。<br />
4.<code>I/O</code>设备的地址分配：一般给寄存器、设备上的存储分配内存地址。<br />
5.<code>I/O</code>设备的访问方式：直接<code>I/O</code>指令（访问寄存器）、内存映射的<code>I/O</code>指令（数据、控制寄存器映射到处理器的地址空间，一般用于访问设备上的大型存储区域）。<br />
<strong>二、轮询与中断</strong><br />
1.轮询：每个<code>I/O</code>操作都是忙等待；指令发送给设备控制器（命令寄存器）；不断读取状态寄存器，直到设备告知指令已经完成。若设备较快，则忙等待较为合理；若设备较慢，则忙等待效率低下。<br />
2.中断：避免忙等待，提高<code>CPU</code>利用率；设备驱动器(<code>OS</code>的一个组件)给设备控制器发送命令后返回，<code>OS</code>调度其余活动；完成指令后，设备中断处理器，<code>OS</code>通过处理中断获得指令结果；需要上下文切换，若中断频率很高，则不如轮询有效。<br />
<strong>三、直接内存访问(<code>Direct Memory Access, DMA</code>)</strong><br />
1.直接在<code>I/O</code>设备和内存间进行数据传输，避免程序控制<code>I/O</code>(<code>Programmed I/O</code>)增加<code>CPU</code>负担。<br />
2.数据以大块形式进行传输；需要设备或系统的<code>DMA</code>控制器进行支持。<br />
3.操作系统给<code>DMA</code>控制器发送命令，一般是将指令的指针写入指令寄存器；操作完成后，设备中断<code>CPU</code>进行通知。<br />
<strong>四、应用程序<code>I/O</code>接口</strong><br />
1.<code>I/O</code>系统调用封装设备的表现；设备驱动层为内核<code>I/O</code>子系统隐藏设备控制器之间的差异。<br />
2.<code>I/O</code>设备的分类：字符流、块；顺序访问、随机访问；同步、异步或同步兼异步；可共享或独占；操作速度；读写、只读、只写。<br />
3.块设备接口(<code>block-device interface</code>)-基本行为有<code>read, write, seek</code>；<code>raw I/O</code>、直接<code>I/O</code>、文件系统访问；可以进行内存映射的文件访问；可提供直接内存访问(<code>DMA</code>)；字符流接口(<code>character-stream interface</code>)-基本系统调用有<code>get, put</code>；网络套接字接口；内存映射的文件访问；时钟和定时器。  <br />
<strong>五、同步与异步<code>I/O</code></strong><br />
1.同步<code>I/O</code>：分为阻塞、非阻塞<code>I/O</code>；阻塞<code>I/O</code>，应用程序挂起，直到<code>I/O</code>操作完成；非阻塞<code>I/O</code>，进程不阻塞，返回已有的数据。<br />
2.异步<code>I/O</code>：在<code>I/O</code>执行的同时，进程也运行；<code>I/O</code>子系统完成操作后发信号告知进程。<br />
<strong>六、<code>I/O</code>调度</strong><br />
1.<code>I/O</code>调度基本概念：对各设备的<code>I/O</code>请求，维护请求队列；通过<code>I/O</code>调度，尽量保证公平性和服务质量。<br />
2.缓冲区-保存在两个设备之间，或设备和应用程序之间传输数据的一块内存区域；作用-处理数据流生产者、消费者之间的速度不匹配问题；解决设备传输大小不一的问题，如计算机网络中缓冲区大量用于消息的分段和重组；支持应用程序<code>I/O</code>的“复制语义”，即保证写道磁盘的数据版本是应用程序进行系统调用时的版本，与应用程序缓冲区的任何后续更改无关。<br />
3.缓存：保存数据的备份，以提供高速访问；一些情况下和缓冲(<code>buffering</code>)结合使用。<br />
4.假脱机(<code>spooling</code>)：<strong>高速磁盘</strong>上的一个缓冲区，若设备一次只能处理一个请求，则暂时保存设备输入（即程序输出）。<br />
5.设备预留：提供设备的额外访问；包含分配、释放的系统调用；检测死锁。<br />
6.错误处理：一些操作系统只返回错误码或<code>I/O</code>请求失败的代码；另一些操作系统则试图从错误中恢复，如读写重试或更高级的错误处理方法。<br />
<strong>七、其他问题</strong>
1.<code>I/O</code>保护：将所有<code>I/O</code>指令设置为特权指令；保护内存映射<code>I/O</code>及<code>I/O</code>端口。<br />
2.内核<code>I/O</code>数据结构：一些内核保存<code>I/O</code>组件的状态信息，如打开文件表、网络连接、字符设备状态等，并追踪缓冲区、内存分配、脏块等信息；另一些内核使用消息传递实现<code>I/O</code>。<br />
3.给硬件的<code>I/O</code>请求：系统资源访问需要映射到硬件，如文件名需要转换为设备表示。<br />
4.性能：内核<code>I/O</code>代码使用<code>CPU</code>执行设备驱动器；中断与上下文切换；数据的缓冲和复制。<br />
5.网络通信：上下文切换频率较高。<br />
6.在<code>I/O</code>层面改善操作系统性能的方法：减少上下文切换次数；减少数据复制；通过使用大规模传输、更小的控制器、轮询，减少中断数量；使用直接内存访问(<code>DMA</code>)；使用更智能的硬件设备；对<code>CPU, memory, bus, I/O performance</code>，以获得最高的吞吐量；将用户模式进程、守护进程移动到内核线程中。<br />
<strong>第十四章 操作系统安全</strong><br />
<strong>一、知识点</strong><br />
<code>TCSEC(Trusted Computer System Evaluation Criteria)</code>、<code>ITSEC(Information Technology Evaluation Criteria)</code>、<code>CC(Common Criteria)</code>；可信基（安全保护机制的集合）、攻击面（组件被其他组件攻击方法的集合）、防御纵深（设置多道防线，为防御增加冗余）；访问控制：认证、授权、审计(<code>Auditing</code>)；自主(<code>Discretionary</code>)、强制(<code>Mandatory</code>)访问控制；内核代码注入、内核代码重用、内核数据攻击。<br />
<strong>习题总结</strong><br />
<strong><code>I/O</code></strong><br />
<strong>一、文件系统基础</strong><br />
1.<code>I/O</code>子系统合理的层次组织排列顺序：用户级<code>I/O</code>软件、设备无关软件、设备驱动程序、中断处理程序。<br />
2.设置磁盘缓冲区的主要目的：减少磁盘<code>I/O</code>。<br />
3.文件的索引节点号位数，决定了能存储文件数量的上限。<br />
4.“阻塞等待”状态就是“睡眠”状态。<br />
<strong>二、目录/文件系统</strong><br />
1.建立软链接（符号链接）时，引用计数直接复制。<br />
2.删除文件时，内核必须释放其磁盘空间，但是快捷方式不一定要处理。<br />
3.注意：盘块和块内字节从<code>0</code>开始编号。<br />
<strong><code>I/O</code>管理</strong><br />
<strong>一、<code>I/O</code>设备概述</strong><br />
1.<code>I/O</code>子系统：用户级别<code>I/O</code>软件-&gt;设备无关软件-&gt;设备驱动程序-&gt;中断处理程序。<br />
2.从磁盘读数据的流程：初始化<code>DMA</code>控制器，启动磁盘-&gt;磁盘传输数据到内存缓冲区-&gt;<code>DMA</code>控制器发出中断请求-&gt;执行<code>DMA</code>结束对应的中断服务程序。<br />
<strong>二、设备独立性软件</strong><br />
1.系统内存设置磁盘缓冲区，主要目的是：减少磁盘<code>I/O</code>次数。<br />
2.<code>Spooling</code>：低速<code>I/O</code>设备上的数据传送到高速磁盘上，或相反；独占设备改成共享设备；需要多道程序支持；设备与输入井、输出井间的传送由系统实现。<br />
<strong>三、磁盘与固态硬盘</strong><br />
磁臂黏着：系统总是访问磁盘的某个磁道而不响应对其他磁道的访问请求。只有<code>FCFS</code>算法不会导致磁臂黏着。<br />
<strong>内存管理</strong><br />
1.系统发生抖动时，撤销用户进程是有效措施，增加磁盘交换区容量没有作用。<br />
2.<code>Best Fit</code>若对空闲分区链进行排序，一般是按照从小到大的顺序。<br />
3.链接阶段形成逻辑地址。<br />
<strong>死锁</strong><br />
1.各进程恰好持有<code>demand count - 1</code>个同类资源，此时的资源总量即为可能死锁的最大资源总量，总量<code>+ 1</code>即为不发生死锁的最小资源量。<br />
2.死锁预防是四种方法中最为严苛的，破坏了死锁四个条件之一，必定不发生死锁；银行家算法只能避免死锁，不能判断系统是否处于死锁状态。  <br />
3.单一资源的安全序列：严格列出现有空闲资源、需求资源，画箭头表示某进程完成任务后空闲资源数量的变化情况。<br />
4.<code>A system is in a deadlock, if its resourceallocation graph contains a cycle and there is just oneinstance of every resource.</code><br />
<strong>信号量设计问题</strong><br />
1.复杂生产者问题（一个盘中只有<code>1</code>的容量，父放苹果给女儿吃，母放苹果给儿子吃，父母操作互斥）<br />
·设置<code>plate = 1, apple = 0, orange = 0</code>，父母生产水果，消耗<code>plate</code>信号量，生产<code>apple/orange</code>信号量；儿子/女儿消耗<code>apple/orange</code>信号量，生产<code>plate</code>信号量。<br />
2.读写公平的读者-写者问题（有写者发出写请求，则现已进入临界区的读进程全部释放后，写进程立马进临界区，不再允许后续读进程加入）<br />
·增设<code>write</code>信号量，原有的<code>read_write</code>信号量不变。写者一开始就请求<code>write</code>，所有操作结束后再释放<code>write</code>；读者获取<code>mutex</code>、更新<code>read_count</code>、更新<code>read_write</code>信号量的过程，被<code>P(write), V(write)</code>包围，一释放<code>mutex</code>就立即释放<code>write</code>信号量。<br />
3.抽烟问题（三个烟民分别需要材料<code>12, 23, 31</code>，生产者一次性生产两种材料，材料拿走后才能继续生产）<br />
·设置信号量<code>finish, offer1, offer2, offer3</code>；生产者消耗信号量<code>finish</code>，循环生产信号量<code>offer1/offer2/offer3</code>；消费者分别消耗<code>offer1/offer2/offer3</code>，生产信号量<code>finish</code>。<br />
4.通用方法：分析互斥关系，设置互斥信号量；分析同步关系，确定一组“循环”信号量的生产、释放分别由哪个进程进行。<br />
<strong>同步</strong><br />
1.对于临界区问题，<code>special machine instruction</code>的解决方法会导致盲等待。<br />
2.<code>Critical section **cannot** be enforced with ageneral semaphore whose initial value is greater than 1.</code><br />
3.<code>In the producer-consumer problem, the orderof wait operations cannot be reversed, while the order of signal
operations can be reversed.</code><br />
<strong>内存管理</strong><br />
<code>Multiple-partition memory allocation scheme may produce external fragmentation.</code><br />
<strong><code>CPU</code>调度</strong><br />
1.<code>A measure of the number of processes completed per time unit is called throughput.</code><br />
2.<code>turnaround time</code>：进程完成时间与进程到达时间的差值。<br />
3.<code>The best process schedulingalgorithm in terms of average waiting time is SJF/SPF.</code><br />
4.高响应⽐优先调度算法：综合考虑进程等待时间和执⾏时间。<br />
5.降低进程优先级的合理时机是：进程用完时间片。<br />
6.满⾜短任务优先且不会发⽣饥饿现象的调度算法：高响应⽐优先调度算法。<br />
<strong>文件系统</strong><br />
1.某文件系统空间的最⼤容量为<code>4TB(1T=240)</code>，以磁盘块为基本分配单位，磁盘块大小为<code>1 KB</code>。⽂件控制块(<code>FCB</code>)包含⼀个<code>512B</code>的索引表区。假设索引表区采用如下结构：第<code>0～7</code>字节采⽤＜起始块号，块数＞格式表示文件创建时预分配的连续存储空间，其中起始块号占<code>6B</code>，块数占<code>2B</code>；剩余504字节采⽤直接索引结构，⼀个索引项占<code>6B</code>，则可支持的单个文件最⼤长度是<code>65620 K</code>字节。<br />
·块号占<code>6</code>字节，块数占<code>2</code>字节的情形下，最大文件长度（字节）：<span class="arithmatex">\(2^{16}×2^{10}+(\frac{504}{6})×2^{10}=65620\)</span>.<br />
·理解：文件占据的总存储空间 = 预分配的连续存储空间 + 直接索引对应的离散存储块空间<br />
2.若采用链接存储方式，则因为下一个文件块的指针占据了<code>4B/8B</code>的数据存储空间，而导致每个块中存储的数据量小于<code>1024B/512B</code>。<br />
3.<code>Commonly, In memory the file control block of a file does not contain the file name.</code><br />
4.<code>In order to solve name collision, the file system normally adopts tree-like directory structure.</code><br />
5.<code>VFS(Virtual File System) allows supporting multiple filesystems.</code><br />
<strong>大容量存储介质</strong><br />
1.<code>RAID 5 provides high reliability inexpensively.</code><br />
2.<code>If a swap space is a raw partition, then it is fastest.</code><br />
3.<code>The I/O control of disk devices mainly adopt DMA(Direct Memory Access).</code><br />
4.<code>SSTF algorithm may change the arm’s movement direction at any moment.</code><br />
<strong>进程</strong><br />
1.操作系统中提供了⼀种进程间的通信机制——管道，把⼀个进程的标准输出与另⼀个进程的标准输⼊连接起来。<br />
2.全局变量不能实现<code>IPC</code>。  </p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.tabs.sticky", "header.autohide"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.e1c3ead8.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
      
    
  </body>
</html>