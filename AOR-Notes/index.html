
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="大观散人">
      
      
        <link rel="canonical" href="https://ZJUZhangJiefu.github.io/AOR-Notes/">
      
      
        <link rel="prev" href="../NA-Notes/">
      
      
        <link rel="next" href="../CP/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.5.3, mkdocs-material-9.5.6">
    
    
      
        <title>期末笔记合订本 - 大观散人的博客</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.50c56a3b.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=仿宋:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"仿宋";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="cyan">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#_1" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow md-header--lifted" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href=".." title="大观散人的博客" class="md-header__button md-logo" aria-label="大观散人的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            大观散人的博客
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              期末笔记合订本
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="cyan" data-md-color-accent="cyan"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 7H7a5 5 0 0 0-5 5 5 5 0 0 0 5 5h10a5 5 0 0 0 5-5 5 5 0 0 0-5-5m0 8a3 3 0 0 1-3-3 3 3 0 0 1 3-3 3 3 0 0 1 3 3 3 3 0 0 1-3 3Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="cyan" data-md-color-accent="cyan"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 6H7c-3.31 0-6 2.69-6 6s2.69 6 6 6h10c3.31 0 6-2.69 6-6s-2.69-6-6-6zm0 10H7c-2.21 0-4-1.79-4-4s1.79-4 4-4h10c2.21 0 4 1.79 4 4s-1.79 4-4 4zM7 9c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/ZJUZhangJiefu/ZJUZhangJiefu.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ZJUZhangJiefu.github.io
  </div>
</a>
      </div>
    
  </nav>
  
    
      
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  
  
    <li class="md-tabs__item">
      <a href=".." class="md-tabs__link">
        
  
    
  
  主页

      </a>
    </li>
  

      
        
  
  
    
  
  
    
    
      
  
  
    
  
  
    
    
      <li class="md-tabs__item md-tabs__item--active">
        <a href="../OS-Notes/" class="md-tabs__link">
          
  
  计算机专业课

        </a>
      </li>
    
  

    
  

      
        
  
  
  
    
    
      
  
  
  
    
    
      <li class="md-tabs__item">
        <a href="../A%20Gentle%20Introduction%20to%20Graph%20Neural%20Networks/" class="md-tabs__link">
          
  
  深度学习专题

        </a>
      </li>
    
  

    
  

      
    </ul>
  </div>
</nav>
    
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="大观散人的博客" class="md-nav__button md-logo" aria-label="大观散人的博客" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    大观散人的博客
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/ZJUZhangJiefu/ZJUZhangJiefu.github.io" title="前往仓库" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ZJUZhangJiefu.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    主页
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="">
            
  
  <span class="md-ellipsis">
    计算机专业课
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            计算机专业课
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
        
          
          <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    操作系统
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_1">
            <span class="md-nav__icon md-icon"></span>
            操作系统
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../OS-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    期末开卷笔记
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
        
          
          <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    计算机视觉
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_2">
            <span class="md-nav__icon md-icon"></span>
            计算机视觉
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Camera%20Model%20and%203D%20Vision/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    专题汇编——相机模型与立体视觉
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CV-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    复习提纲全解
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    数值分析
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            数值分析
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../NA-Notes/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    数值分析笔记
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" checked>
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    应用运筹学基础
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            应用运筹学基础
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    期末笔记合订本
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    期末笔记合订本
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第一讲
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第二讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第二讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      一、最优化模型——基本结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      二、最优化模型——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      三、最优化问题——基本性质
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第三讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第三讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      一、线性规划
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      二、单纯形法基本原理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第四讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第四讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      一、单纯形法——回顾
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      二、线性规划基本对偶理论
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      三、对偶的性质
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第五讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第五讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      一、对偶单纯形法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      二、互补-松弛定理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    <span class="md-ellipsis">
      三、原始-对偶方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    <span class="md-ellipsis">
      四、最短路问题的原始-对偶算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第六讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第六讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    <span class="md-ellipsis">
      一、最短路问题的原始-对偶算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      二、整数线性规划——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      三、求解整数线性规划的基本框架
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第七讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第七讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gomory" class="md-nav__link">
    <span class="md-ellipsis">
      一、整数规划基本算法——Gomory割平面法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      二、整数规划基本算法——分枝定界法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      三、近似比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      四、基于线性规划的近似算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      一、两类基本优化问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      二、若干优化问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      三、贪心算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      四、秩商估计式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十一讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十一讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      一、独立系统的对偶
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      二、拟阵——定义与性质
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      三、拟阵——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      四、拟阵的交
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      五、拟阵与秩商估计式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十二讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十二讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      一、装箱问题及其近似算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-fit" class="md-nav__link">
    <span class="md-ellipsis">
      二、First-Fit算法近似情况分析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kkkarmarkar-karp" class="md-nav__link">
    <span class="md-ellipsis">
      三、KK(Karmarkar &amp; Karp)算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十三讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十三讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      一、在线算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k-" class="md-nav__link">
    <span class="md-ellipsis">
      二、\(k\)-服务器问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十四讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十四讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k-k-dcdouble-cover" class="md-nav__link">
    <span class="md-ellipsis">
      一、一维k-服务器问题——k-竞争DC(Double Cover)算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k-_1" class="md-nav__link">
    <span class="md-ellipsis">
      二、\(k\)-服务器问题——补充与拓展
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_5" >
        
          
          <label class="md-nav__link" for="__nav_2_5" id="__nav_2_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    编译原理
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_5">
            <span class="md-nav__icon md-icon"></span>
            编译原理
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    编译原理 笔记合订本
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
      
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="">
            
  
  <span class="md-ellipsis">
    深度学习专题
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            深度学习专题
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    GNN
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            GNN
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../A%20Gentle%20Introduction%20to%20Graph%20Neural%20Networks/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    图神经网络导论
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Transformer
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            Transformer
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Attention%20Is%20All%20You%20Need/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Attention Is All You Need(NIPS 2017)
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    扩散模型
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            扩散模型
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DDPM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    去噪扩散概率模型
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    优化器
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            优化器
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Descending%20Through%20A%20Crowded%20Valley/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Descending Through A Crowded Valley(ICML 2021)
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
        
          
          <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    分子对接
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_5">
            <span class="md-nav__icon md-icon"></span>
            分子对接
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DSDP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    DSDP - A Blind Docking Strategy Accelerated by GPUs
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
        
          
          <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    逆合成预测
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_6">
            <span class="md-nav__icon md-icon"></span>
            逆合成预测
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../G2GT/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    G2GT - Retrosynthesis Prediction with Graph-to-Graph Attention Neural Network and Self-Training
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第一讲
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第二讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第二讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      一、最优化模型——基本结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      二、最优化模型——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      三、最优化问题——基本性质
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第三讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第三讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      一、线性规划
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      二、单纯形法基本原理
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第四讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第四讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      一、单纯形法——回顾
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      二、线性规划基本对偶理论
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      三、对偶的性质
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第五讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第五讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      一、对偶单纯形法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      二、互补-松弛定理
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_1" class="md-nav__link">
    <span class="md-ellipsis">
      三、原始-对偶方法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#-_2" class="md-nav__link">
    <span class="md-ellipsis">
      四、最短路问题的原始-对偶算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第六讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第六讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#-_3" class="md-nav__link">
    <span class="md-ellipsis">
      一、最短路问题的原始-对偶算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      二、整数线性规划——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      三、求解整数线性规划的基本框架
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第七讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第七讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#gomory" class="md-nav__link">
    <span class="md-ellipsis">
      一、整数规划基本算法——Gomory割平面法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      二、整数规划基本算法——分枝定界法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      三、近似比
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      四、基于线性规划的近似算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      一、两类基本优化问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      二、若干优化问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      三、贪心算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      四、秩商估计式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十一讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十一讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      一、独立系统的对偶
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      二、拟阵——定义与性质
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      三、拟阵——举例
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      四、拟阵的交
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      五、拟阵与秩商估计式
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十二讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十二讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      一、装箱问题及其近似算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#first-fit" class="md-nav__link">
    <span class="md-ellipsis">
      二、First-Fit算法近似情况分析
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kkkarmarkar-karp" class="md-nav__link">
    <span class="md-ellipsis">
      三、KK(Karmarkar &amp; Karp)算法
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十三讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十三讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      一、在线算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k-" class="md-nav__link">
    <span class="md-ellipsis">
      二、\(k\)-服务器问题
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      应用运筹学基础 第十四讲
    </span>
  </a>
  
    <nav class="md-nav" aria-label="应用运筹学基础 第十四讲">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#k-k-dcdouble-cover" class="md-nav__link">
    <span class="md-ellipsis">
      一、一维k-服务器问题——k-竞争DC(Double Cover)算法
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#k-_1" class="md-nav__link">
    <span class="md-ellipsis">
      二、\(k\)-服务器问题——补充与拓展
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


  <h1>期末笔记合订本</h1>

<h4 id="_1">应用运筹学基础 第一讲</h4>
<h4 id="_2">应用运筹学基础 第二讲</h4>
<h5 id="_3">一、最优化模型——基本结构</h5>
<p>1.【定义1】凸集<br />
若<span class="arithmatex">\(\forall x, y \in C, \forall \lambda \in (0, 1)\)</span>，都有<span class="arithmatex">\(\lambda x + (1 - \lambda)y \in C\)</span>，则称集合<span class="arithmatex">\(C\)</span>是<strong>凸集</strong>。<br />
【理解】凸集：任取集合中两点，这两点连成的线段上所有点都在集合中。<br />
2.【定义2】凸函数<br />
若函数<span class="arithmatex">\(f(x)\)</span>满足以下两个条件：<br />
（1）函数<strong>定义在凸集<span class="arithmatex">\(C\)</span>上</strong>。<br />
（2）<span class="arithmatex">\(\forall x, y \in C,\forall 0 \lt \lambda \lt 1, f(\lambda x + (1 - \lambda y))\le \lambda f(x) + (1 - \lambda)f(y)\)</span>。
则称函数<span class="arithmatex">\(f(x)\)</span>为<strong>凸函数</strong>。<br />
3.【定义3】凸优化<br />
称定义在凸集<span class="arithmatex">\(C\)</span>上，针对凸函数<span class="arithmatex">\(f\)</span>进行的极小优化问题为凸优化问题。<br />
4.【定理1】凸优化问题中，局部最优解就是整体最优解。<br />
【证明】<br />
（1）设<span class="arithmatex">\(\bar{x}\)</span>为局部最优解，<span class="arithmatex">\(x^* \ne \bar{x}\)</span>为全局最小的解，即<span class="arithmatex">\(f(\bar{x}) \gt f(x^*)\)</span>，用反证法。<br />
（2）连接<span class="arithmatex">\(\bar{x}. x^*\)</span>，由凸函数性质，<span class="arithmatex">\(\forall x' \in \bar{x} x^*\)</span>，都<span class="arithmatex">\(\exists \lambda \in (0, 1)\)</span>, 使得<span class="arithmatex">\(f(x) = \lambda f(\bar{x}) + (1 - \lambda)f(x^*) \lt \lambda f(\bar{x}) + (1 - \lambda)f(\bar{x}) = f(\bar{x})\)</span>，因此<span class="arithmatex">\(\bar{x}\)</span>不是局部最优解，矛盾。<br />
5.【拓展定义1】上方图(<code>epigraph</code>)<br />
称<span class="arithmatex">\(\{(z, x): f(x) \le Z, \forall x \in C\}\)</span>为<span class="arithmatex">\(f(x)\)</span>的上方图。<br />
6.【拓展性质1】<span class="arithmatex">\(f(x)\)</span>为凸函数，当且仅当上方图是凸的。  </p>
<h5 id="_4">二、最优化模型——举例</h5>
<p>1.生产计划问题<br />
（1）问题描述  </p>
<table>
    <tr>
        <td></td> 
        <td>产品A</td> 
        <td>产品B</td> 
        <td>产品C</td>
        <td>库存</td>  
   </tr>
    <tr>
        <td>材料一</td> 
        <td>5</td> 
        <td>15</td>
        <td>0</td> 
        <td>300</td>
    </tr>
    <tr>
        <td>材料二</td> 
        <td>10</td> 
        <td>0</td> 
        <td>20</td> 
        <td>200</td>
    </tr>
    <tr>
        <td>利润</td> 
        <td>100</td> 
        <td>200</td> 
        <td>300</td> 
        <td></td>
    </tr>
</table>

<p>（2）优化目标<br />
设产品<span class="arithmatex">\(A, B, C\)</span>的产量分别为<span class="arithmatex">\(x_1, x_2, x_3\)</span>，则优化目标为：<br />
<span class="arithmatex">\(max \space 100 x_1 + 200 x_2 + 300 x_3\)</span><br />
等价于：<br />
<span class="arithmatex">\(min \space -(100 x_1 + 200 x_2 + 300 x_3)\)</span><br />
（3）约束条件： <br />
<span class="arithmatex">\(5x_1 + 15x_2 \le 300\)</span><br />
<span class="arithmatex">\(10x_1 + 20 x_3 \le 200\)</span><br />
<span class="arithmatex">\(x_1, x_2, x_3 \ge 0\)</span><br />
（4）线性规划的约束区域一般为凸区域，即若干超平面围成的凸多面体。<br />
（5）一般形式<br />
<span class="arithmatex">\(max \space \vec{c}^T \vec{x}  
\newline s.t. \space A\vec{x} \le \vec{b}  \newline \space \space \space\space\space\space\space\vec{x} \ge 0\)</span><br />
2.网络流——最大流问题<br />
（1）约束条件<br />
·进出平衡<br />
·流量限制<br />
（2）决策变量：各边的实际流量<span class="arithmatex">\(x_{s,1}, x_{s,2}, \cdots, x_{n-1,t}, x_{n,t}\)</span>。<br />
（3）优化目标：<span class="arithmatex">\(max \space x_{s, 1}, \cdots, x_{s, k}\)</span>，即从源点<span class="arithmatex">\(s\)</span>发出的流量之和。<br />
（4）约束：<br />
①平衡约束：<span class="arithmatex">\(x_{s, 1} - x_{1, 2} - x_{1, 3} = 0\)</span>。<br />
②容量约束：<span class="arithmatex">\(x_{s, 1} \le c_{s, 1}\)</span>。<br />
③流量非负性：<span class="arithmatex">\(\vec{x} \ge 0\)</span>.<br />
（5）引入从汇点<span class="arithmatex">\(t\)</span>到源点<span class="arithmatex">\(s\)</span>的回流，则源点、汇点也可以直接使用上述平衡约束。<br />
3.运输问题<br />
（1）问题描述<br />
供应商存量<span class="arithmatex">\(b_1, \cdots, b_m\)</span>，仓库需求<span class="arithmatex">\(D_1, \cdots, D_n\)</span>，从供应商<span class="arithmatex">\(i\)</span>到仓库<span class="arithmatex">\(j\)</span>，单位货物的运费为<span class="arithmatex">\(c_{ij}\)</span>。<br />
（2）优化目标<br />
设从供应商<span class="arithmatex">\(i\)</span>到仓库<span class="arithmatex">\(j\)</span>的实际运量为<span class="arithmatex">\(x_{ij}\)</span>，则优化目标为：<br />
<span class="arithmatex">\(min \space \Sigma_{i = 1}^m \Sigma_{j = 1}^n c_{ij}x_{ij}\)</span>。<br />
（3）约束条件：<br />
①供需平衡：<span class="arithmatex">\(\Sigma_{i = 1}^m b_i = \Sigma_{j = 1}^n D_j\)</span><br />
②各仓库需求约束：<span class="arithmatex">\(\Sigma _{j = 1}^n x_{ij} = D_i\)</span><br />
③各供应商供应约束：<span class="arithmatex">\(\Sigma _{i = 1}^m x_{ij} = b_j\)</span><br />
（3）问题变形<br />
·供求不平衡问题<br />
·不连续问题  </p>
<h5 id="_5">三、最优化问题——基本性质</h5>
<p>1.【定义4】松弛<br />
为不等式添加非负变量，使之变成等式的处理，称为松弛。<br />
2.【定义5】极点的几何定义<br />
给定凸集<span class="arithmatex">\(C\)</span>以及<span class="arithmatex">\(C\)</span>中一点<span class="arithmatex">\(x\)</span>，若<span class="arithmatex">\(\forall y, z \in C, \forall \lambda \in (0, 1)\)</span>，只有<span class="arithmatex">\(x = y = z\)</span>时才成立<span class="arithmatex">\(\lambda y + (1 - \lambda)z = x\)</span>，则称<span class="arithmatex">\(C\)</span>是凸集上的一个<strong>极点</strong>。<br />
【理解】极点<span class="arithmatex">\(x\)</span>的几何定义，即<span class="arithmatex">\(x\)</span>不能由凸集<span class="arithmatex">\(C\)</span>中其余任意两点进行线性表示。<br />
3.【定理2】某线性规划问题若有有限最优解，则必定存在最优解在它的某个极点达到。<br />
4.【定义6】线性规划的基本可行解<br />
设<span class="arithmatex">\(A\vec{x} = \vec{b}, r(A) = m \le n\)</span>，<span class="arithmatex">\(A_B = (P_1, \cdots, P_1)\)</span>为矩阵<span class="arithmatex">\(A\)</span>的一个基，若<span class="arithmatex">\(\vec{x} = [\vec{x_B}, \vec{x_N}]^T\)</span>满足：<br />
（1）<span class="arithmatex">\(\vec{x_B} = A_B^{-1}\vec{b}\)</span>。<br />
（2）<span class="arithmatex">\(\vec{x_N}\)</span>为零向量。<br />
（3）<span class="arithmatex">\(\vec{x}\)</span>满足所有线性规划约束条件，是可行解。<br />
则称<span class="arithmatex">\(x\)</span>是线性规划问题的一个<strong>基本可行解</strong>。<br />
【理解】分块矩阵乘法：<span class="arithmatex">\(A\vec{x} = [A_B, A_N][\vec{x_B}, \vec{x_N}]^T = A_B\vec{x_B} + A_N\vec{x_N} = \vec{b}\)</span>，由于<span class="arithmatex">\(A_N\vec{x_N} = \vec{0}\)</span>，故<span class="arithmatex">\(\vec{x_B} = A_B^{-1}\vec{b}\)</span>。<br />
5.【定理3】<br />
线性规划问题中，<span class="arithmatex">\(x\)</span>是极点，当且仅当<span class="arithmatex">\(x\)</span>是基本可行解。<br />
【理解】线性规划问题，从针对整个可行域进行搜索，转化为只需针对有限个极点（基本可行解）进行搜索，转化为组合优化问题。  </p>
<h4 id="_6">应用运筹学基础 第三讲</h4>
<h5 id="_7">一、线性规划</h5>
<p>1.线性规划解的情况<br />
对于以下标准线性规划9松弛形式）：<br />
<span class="arithmatex">\(max \space c^Tx
\newline s.t. \space A\vec{x} = \vec{b}
\newline \space\space\space\space\space\space\space \vec{x} \ge 0\)</span><br />
解的可能情况如下：<br />
（1）无可行解。<br />
（2）有可行解，且有有限最优解。<br />
（3）有可行解，但无有限最优解。<br />
2.注意：为了方便应用单纯形法，应该<strong>将所有的不等式约束转换成等式约束</strong>，即转换成松弛形式。<br />
3.初始可行解的获得<br />
·对于不等式约束<span class="arithmatex">\(A \vec{x} \le \vec{b}\)</span>，首先添加松弛向量<span class="arithmatex">\(\vec{s}\)</span>，将其变为等式约束：<span class="arithmatex">\(A\vec{x} + \vec{s} = \vec{b}\)</span>.<br />
·此时，令松弛向量<span class="arithmatex">\(\vec{s} = \vec{b}\)</span>，同时原始向量<span class="arithmatex">\(\vec{x} = \vec{0}\)</span>，即得到一个初始可行解。<br />
4.基本可行解、极点定义<br />
（1）【定义】极点<br />
给定凸集<span class="arithmatex">\(C\)</span>以及<span class="arithmatex">\(C\)</span>中一点<span class="arithmatex">\(x\)</span>，若<span class="arithmatex">\(\forall y, z \in C, \forall \lambda \in (0, 1)\)</span>，只有<span class="arithmatex">\(x = y = z\)</span>时才成立<span class="arithmatex">\(\lambda y + (1 - \lambda)z = x\)</span>，则称<span class="arithmatex">\(C\)</span>是凸集上的一个<strong>极点</strong>。<br />
（2）【定义】基本可行解<br />
设<span class="arithmatex">\(A\vec{x} = \vec{b}, r(A) = m \le n\)</span>，<span class="arithmatex">\(A_B = (P_1, \cdots, P_1)\)</span>为矩阵<span class="arithmatex">\(A\)</span>的一个基，若<span class="arithmatex">\(\vec{x} = [\vec{x_B}, \vec{x_N}]^T\)</span>满足：<br />
（1）<span class="arithmatex">\(\vec{x_B} = A_B^{-1}\vec{b}\)</span>。<br />
（2）<span class="arithmatex">\(\vec{x_N}\)</span>为零向量。<br />
（3）<span class="arithmatex">\(\vec{x}\)</span>满足所有线性规划约束条件，是可行解。<br />
则称<span class="arithmatex">\(x\)</span>是线性规划问题的一个<strong>基本可行解</strong>。<br />
5.线性规划的凹凸性质<br />
（1）线性规划问题的目标函数，<strong>既是凸函数，又是凹函数</strong>。<br />
（2）对于凸优化而言，局部最优即为全局最优。凸优化的目标是，在凸集上极小化凸函数。<br />
（3）由于<strong>线性规划问题的目标函数同时是凹函数、凸函数</strong>，故对于该问题而言，<strong>极小化凸函数等价于极大化凹函数</strong>，对应了线性规划<strong>最小化目标函数和最大化目标函数相反数</strong>的<strong>等价</strong>性质。<br />
【注】<br />
（1）基本可行解的表达——拆分成基变量和非基变量<br />
<span class="arithmatex">\(x = \begin{bmatrix}
x_B\\
x_N\\
\end{bmatrix} = \begin{bmatrix}
A_B^{-1}b\\ 
0\\
\end{bmatrix}\)</span>.<br />
（2）拆分<span class="arithmatex">\(A\vec{x} = \vec{b}\)</span>：
$
\begin{bmatrix}
A_B \ A_N \
\end{bmatrix}
\begin{bmatrix}
x_B \
x_N \
\end{bmatrix} = b
$
上式等价于：<span class="arithmatex">\(\vec{x_B} = A_B^{-1}\vec{b}\)</span>.<br />
（3）基本可行解的个数至多为<span class="arithmatex">\(C_n^m\)</span>，其中<span class="arithmatex">\(m\)</span>为矩阵的秩，<span class="arithmatex">\(n\)</span>为变量个数。<br />
（4）线性规划问题若有有限最优解，则必定存在最优解从<strong>有限个基本可行解</strong>中产生，因此线性规划可以转化为<strong>组合优化</strong>问题。<br />
6.【定理1】线性规划的<strong>极点等价于基本可行解</strong>。<br />
【证明】<br />
（1）<span class="arithmatex">\(\rightarrow\)</span>方向，设<span class="arithmatex">\(x\)</span>是极点，下证<span class="arithmatex">\(x\)</span>是基本可行解。<br />
①<strong>证明逆否命题</strong>。假设<span class="arithmatex">\(x\)</span>不是基本可行解，我们要推出<span class="arithmatex">\(x\)</span>不是极点，即构造可行解<span class="arithmatex">\(x', x''\)</span>，使得<span class="arithmatex">\(x\)</span>能被<span class="arithmatex">\(x', x''\)</span>线性表示。<br />
②将<span class="arithmatex">\(x\)</span>写作<span class="arithmatex">\(x = \begin{bmatrix} x_1, \ x_2, \ \cdots, \ x_k, \ 0, \ \cdots, \ 0 \end{bmatrix}^T\)</span>，表示前<span class="arithmatex">\(k\)</span>个分量为正分量，
则前<span class="arithmatex">\(k\)</span>个正分量对应的<strong>列向量必定线性相关</strong>，
即：<span class="arithmatex">\(\exists \lambda_i, i = 1, 2, \cdots\)</span>不全为<span class="arithmatex">\(0\)</span>，使<span class="arithmatex">\(\lambda_1\vec{a_1} + \lambda_2\vec{a_2} + \cdots + \lambda_k\vec{a_k} = 0\)</span>。
③给<span class="arithmatex">\(x\)</span>添加扰动<span class="arithmatex">\(\epsilon\)</span>.<br />
令<span class="arithmatex">\(x' = x + \epsilon \begin{bmatrix} \lambda_1, \cdots, \lambda_k, 0, \cdots, 0  \end{bmatrix}^T\)</span><br />
<span class="arithmatex">\(x'' = x - \epsilon \begin{bmatrix} \lambda_1, \cdots, \lambda_k, 0, \cdots, 0  \end{bmatrix}^T\)</span>
故<span class="arithmatex">\(x = \frac{1}{2}(x' + x'')\)</span>
并且<span class="arithmatex">\(Ax' = Ax + A \epsilon \begin{bmatrix} \lambda_1, \cdots, \lambda_k, 0, \cdots, 0  \end{bmatrix}^T = Ax = b\)</span>，
同样地，<span class="arithmatex">\(Ax''=b\)</span>。<br />
④故<span class="arithmatex">\(x\)</span>不是极点。<br />
（2）<span class="arithmatex">\(\leftarrow\)</span>方向，设<span class="arithmatex">\(x\)</span>是基本可行解，下证<span class="arithmatex">\(x\)</span>是极点。<br />
①<strong>证明逆否命题</strong>。假设<span class="arithmatex">\(x\)</span>不是极点，我们要推出<span class="arithmatex">\(x\)</span>不是基本可行解，即<span class="arithmatex">\(x\)</span>对应的列向量线性相关，无法构成基。<br />
②设<span class="arithmatex">\(x\)</span>不是极点，则存在不同的可行解<span class="arithmatex">\(x', x''\)</span>，使得<span class="arithmatex">\(x = \lambda x' +(1 - \lambda)x'', 0 \lt \lambda \lt 1\)</span>.<br />
③将<span class="arithmatex">\(x\)</span>写成<span class="arithmatex">\(x = \begin{bmatrix} x_1, \ x_2, \ \cdots, \ x_k, \ 0, \ \cdots, \ 0 \end{bmatrix}^T\)</span>,
则<span class="arithmatex">\(x_1\)</span>只能写成<span class="arithmatex">\(x = \begin{bmatrix} x_1', \ x_2', \ \cdots, \ x_k', \ 0, \ \cdots, \ 0 \end{bmatrix}^T\)</span>，
<span class="arithmatex">\(x_2\)</span>只能写成<span class="arithmatex">\(x = \begin{bmatrix} x_1', \ x_2', \ \cdots, \ x_k', \ 0, \ \cdots, \ 0 \end{bmatrix}^T\)</span><br />
④注意到<span class="arithmatex">\(A(x' - x'') = \vec{0}, x - x'' \ne \vec{0}\)</span>，作转置、拆分可得：
<span class="arithmatex">\((x_1' - x_1'')\vec{a_1} + \cdots + (x_k' - x_k'')\vec{a_k} = 0\)</span><br />
这说明列向量<span class="arithmatex">\(a_1, \cdots, a_k\)</span>线性相关，
从而矩阵<span class="arithmatex">\([a_1, \cdots, a_k]^T\)</span>不是基，<span class="arithmatex">\(x\)</span>不是基本可行解。<br />
（3）证毕。  </p>
<h5 id="_8">二、单纯形法基本原理</h5>
<p>1.【例1】单纯形法的运算步骤<br />
<span class="arithmatex">\(max \space 20 x_1 + 30 x_2 \newline
s.t.\space 6x_1 + 3x_2 + x_3 = 40 \newline
\space\space\space\space\space\space\space 2x_1 + 5x_2 + x_4 = 50 \newline
\space\space\space\space\space\space\space x_1, x_2, x_3, x_4 \ge 0\)</span><br />
（1）初始可行解的获得：
令<span class="arithmatex">\(\vec{x} = [0, 0, 40, 50]^T\)</span>即得初始可行解。<br />
（2）使用非基变量，表示基变量、目标函数，化为典则形式：<br />
<span class="arithmatex">\(x_3 = 40 - 6x_1 - 3x_2 \newline
x_4 = 50 - 2x_1 - 5x_2 \newline
z = 20x_1 + 30 x_2\)</span><br />
（3）注意到目标函数的两个检验数均为正，令增速更大的<span class="arithmatex">\(x_2\)</span>入基，此时<span class="arithmatex">\(x_2 = 10\)</span>，<span class="arithmatex">\(x_4 = 0\)</span>，<span class="arithmatex">\(x = [0, 10, 10, 0]^T\)</span>，目标函数值为<span class="arithmatex">\(300\)</span>。<br />
（4）此时新的典则形式如下：<br />
<span class="arithmatex">\(x_2 = 10 - \frac{2}{5}x_1 - \frac{1}{5}x_4 
\newline x_3 = 10 - \frac{24}{5}x_1 + \frac{3}{5}x_4 
\newline z = 8x_1 - 6 x_4 + 300\)</span><br />
（5）注意到检验数<span class="arithmatex">\(8\)</span>为正，令<span class="arithmatex">\(x_1\)</span>入基，<span class="arithmatex">\(x_3\)</span>出基，此时的解变成<span class="arithmatex">\(x = [\frac{25}{12}, \frac{55}{6}, 0, 0]^T\)</span>，目标函数值为<span class="arithmatex">\(\frac{950}{3}\)</span>。<br />
（6）新的典则形式为：<br />
<span class="arithmatex">\(x_1 = \frac{25}{12} + \frac{1}{8}x_4 - \frac{5}{24}x_3\newline
x_2 = \frac{55}{6} + \frac{1}{12}x_3 - \frac{1}{4}x_4
\newline z = \frac{950}{3} - \frac{5}{3}x_3 - 5x_4\)</span><br />
（7）此时检验数均为负，目标函数无法再进行提升，因此本题的最优目标函数值为<span class="arithmatex">\(\frac{950}{3}\)</span>，对应的一个最优解为<span class="arithmatex">\(x = [\frac{25}{12}, \frac{55}{6}, 0, 0]^T\)</span>。<br />
2.方法总结<br />
（1）对于最大化问题，用非基变量表示基变量、目标函数，化成典则形式。<br />
（2）选取检验数为正，且检验数数值最大的非基变量入基。<br />
（3）迭代至各检验数均不是整数，即得最优解。<br />
3.一般形式<br />
（1）分块矩阵<br />
<span class="arithmatex">\(x = [x_B, x_N]^T 
\newline A = [A_B, A_N]\)</span><br />
（2）方程
<span class="arithmatex">\(A_Bx_B + A_Nx_N = b 
\newline z = c^Tx = c_B^Tx_B + c_N^Tx_N\)</span><br />
（3）典则形式<br />
<span class="arithmatex">\(x_B = A_B^{-1}b - A_B^{-1}A_Nx_N\)</span><br />
<span class="arithmatex">\(z = c_B^TA_B^{-1}b + (C_N^T - c_B^TA_B^{-1}b)x_N\)</span><br />
（4）若检验数<span class="arithmatex">\(C_N^T - c_B^TA_B^{-1}b\)</span>存在正分量，则选取正检验数数值最大的非基变量入基进行迭代；若检验数各分量均非正数，即达到最优解<span class="arithmatex">\(x_B = c_B^TA_B^{-1}b\)</span>。<br />
【理解】<br />
（1）<span class="arithmatex">\(A_Bx_B + A_N x_N = b\)</span><br />
（2）两边同时左乘<span class="arithmatex">\(A_B^{-1}\)</span>，目的是将<span class="arithmatex">\(x_B\)</span>的系数矩阵化为单位矩阵，即<span class="arithmatex">\(x_B + A_B^{-1}A_Nx_N = A_B^{-1}b\)</span>。<br />
（3）移项，得到用非基变量线性表示基变量的表达式：<span class="arithmatex">\(x_B = A_B^{-1}b - A_B^{-1}A_Nx_N\)</span><br />
（4）<span class="arithmatex">\(z = c^Tx = c_B^Tx_B + c_N^Tx_N\)</span><br />
（5）代入<span class="arithmatex">\(x_B = A_B^{-1}b - A_B^{-1}A_Nx_N\)</span>，得到：<br />
<span class="arithmatex">\(z = c_B^T(A_B^{-1}b - A_B^{-1}A_Nx_N) + c_N^Tx_N\)</span><br />
（6）提取<span class="arithmatex">\(x_N\)</span>的系数，得到用非基变量线性表示目标函数的表达式：<br />
<span class="arithmatex">\(z = c_B^TA_B^{-1}b + (C_N^T - c_B^TA_B^{-1}b)x_N\)</span><br />
4.入基的矩阵形式<br />
设<span class="arithmatex">\(x_B = A_B^{-1}b - \bar{A}x_N\)</span>，其中<span class="arithmatex">\(\bar{A} = A_B^{-1}A_N\)</span>，检验数向量<span class="arithmatex">\(\sigma = C_N^T - c_B^TA_B^{-1}b\)</span>。<br />
（1）若<span class="arithmatex">\(\exists \sigma_j \gt 0\)</span>，且<span class="arithmatex">\(\forall i, a_{ij} \le 0\)</span>，则该问题没有有限最优解。<br />
（2）若<span class="arithmatex">\(\sigma_j \gt 0\)</span>，令<span class="arithmatex">\(x_j\)</span>入基，则<span class="arithmatex">\(i = min_{a_{ij} \gt 0}\frac{b_i}{a_{ij}}\)</span>相应的<span class="arithmatex">\(x_i\)</span>被提出。<br />
5.单纯型表<br />
（1）原始形式<br />
<span class="arithmatex">\(\left[\begin{array}{c|cc|c}
     &amp; c_B^T &amp; c_N^T &amp; \\
    x_B &amp; A_B &amp; A_N &amp; b\\
\end{array}\right]\)</span><br />
（2）典则形式<br />
<span class="arithmatex">\([\begin{array}{c|cc|c}
     &amp; 0 &amp; c_B^T - c_N^TA_B^{-1}A_N &amp; -c_B^TA_B^{-1}b\\
    x_B &amp; I &amp; A_B^{-1}A_N &amp; A_B^{-1}b\\
\end{array}]\)</span><br />
①上表中，<span class="arithmatex">\(c_B^T - c_N^TA_B^{-1}A_N\)</span>为检验数。<br />
②上表中，<span class="arithmatex">\(-c_B^TA_B^{-1}b\)</span>为当前目标函数值的相反数。  </p>
<h4 id="_9">应用运筹学基础 第四讲</h4>
<h5 id="_10">一、单纯形法——回顾</h5>
<p>1.初始形式<br />
<span class="arithmatex">\(\left[\begin{array}{c|cc|c}
     &amp; c_B^T &amp; c_N^T &amp; \\
    x_B &amp; A_B &amp; A_N &amp; b\\
\end{array}\right]\)</span><br />
2.经过行变换，利用非基变量表示基变量、目标函数，化为典则形式：<br />
<span class="arithmatex">\(\left[\begin{array}{c|cc|c}
     &amp; 0 &amp; c_B^T - c_N^TA_B^{-1}A_N &amp; -c_B^TA_B^{-1}b\\
    x_B &amp; I &amp; A_B^{-1}A_N &amp; A_B^{-1}b\\
\end{array}\right]\)</span><br />
3.【例1】运用单纯形法解决线性规划问题<br />
<span class="arithmatex">\(max \space z = x_1 + 2 x_2\)</span><br />
<span class="arithmatex">\(s.t. \space x_1 + x_2 + x_3 = 3\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_2 + x_4 = 1\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_1, x_2, x_3, x_4 \ge 0\)</span><br />
（1）初始单纯性表<br />
<span class="arithmatex">\(\left[\begin{array}{c|cccc|c}
     &amp; 1 &amp; 2 &amp; 0 &amp; 0 &amp;  \\ 
    x_3 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 3 \\ 
    x_4 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\ 
\end{array}\right]\)</span><br />
（2）令<span class="arithmatex">\(x_2\)</span>入基，<span class="arithmatex">\(x_4\)</span>出基，对初始单纯形表进行行变换，化成新的典则形式：<br />
<span class="arithmatex">\(\left[\begin{array}{c|cccc|c}
     &amp; 1 &amp; 0 &amp; 0 &amp; -2 &amp; -2 \\ 
    x_3 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 2 \\ 
    x_2 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\ 
\end{array}\right]\)</span><br />
（3）令<span class="arithmatex">\(x_1\)</span>入基，<span class="arithmatex">\(x_3\)</span>出基，化成新的典则形式：<br />
<span class="arithmatex">\(\left[\begin{array}{c|cccc|c}
     &amp; 0 &amp; 0 &amp; -1 &amp; -1 &amp; -4 \\ 
    x_1 &amp; 1 &amp; 0 &amp; 1 &amp; -1 &amp; 2 \\ 
    x_2 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 1 \\ 
\end{array}\right]\)</span><br />
（4）此时各检验数均小于等于<span class="arithmatex">\(0\)</span>，故该问题的最优目标函数值为<span class="arithmatex">\(4\)</span>，一个最优解为<span class="arithmatex">\(x = [2, 1, 0, 0]^T\)</span>。<br />
4.入基变量的选择<br />
若总是选择最小下标，或总是选择最大下标的变量，则可避免循环。<br />
5.线性规划可行性的一种判别方法<br />
（1）设原问题的约束条件为<span class="arithmatex">\(Ax \le b\)</span>，<br />
引入松弛向量<span class="arithmatex">\(\bar{x}\)</span>，使得<span class="arithmatex">\(Ax + \bar{x} = b\)</span><br />
（2）令<span class="arithmatex">\(\bar{x} = b, x = 0\)</span>，即得一组初始可行解。<br />
（3）考虑线性规划问题<span class="arithmatex">\((Q)\)</span>：<br />
<span class="arithmatex">\(min \space \Sigma_{n = 1}^m \bar{x_i}\)</span>
<span class="arithmatex">\(s.t. \space Ax + \bar{x} = b\)</span>
<span class="arithmatex">\(\space \space \space \space \space \space \space x \ge 0\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \bar{x} \ge 0\)</span><br />
（4）若<span class="arithmatex">\((Q)\)</span>的最优目标函数值为<span class="arithmatex">\(0\)</span>，则原问题有可行解；若<span class="arithmatex">\((Q)\)</span>的最优目标函数值大于<span class="arithmatex">\(0\)</span>，则原问题没有可行解。  </p>
<h5 id="_11">二、线性规划基本对偶理论</h5>
<p>1.对偶的引出<br />
【例2】<span class="arithmatex">\(max \space 4x_1 + x_2 + 3 x_3 \cdots(1)\)</span>
<span class="arithmatex">\(s.t. \space x_1 + 4x_2 \le 1\cdots(2)\)</span> 
<span class="arithmatex">\(\space \space \space \space \space \space \space 3x_1 - x_2 + x_3 \le 3\cdots(3)\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_1, x_2, x_3 \ge 0\)</span><br />
（1）任取一个可行解，即得到最优目标函数值的一个下界。令<span class="arithmatex">\(\vec{x} = [1, 0, 0]^T\)</span>，即得最优目标函数值的一个下界<span class="arithmatex">\(4\)</span>。<br />
（2）对偶问题的研究目的：寻找一种方法，以估计最大化问题的上界。<br />
（3）观察：<span class="arithmatex">\((2) + 3 \times (3)\)</span>可得：<br />
<span class="arithmatex">\(10 x_1 + x_2 + 3x_3 \le 10\)</span>，因此<span class="arithmatex">\(10\)</span>是原问题的一个上界。<br />
（4）对偶问题思想：由<strong>约束条件的变换</strong>，得到<strong>最优解的上界</strong>。<br />
（5）令约束条件<span class="arithmatex">\((2), (3)\)</span>分别对应于变量<span class="arithmatex">\(y_1, y_2\)</span>，观察约束条件、目标函数中各变量<span class="arithmatex">\(x_i\)</span>的系数：<br />
<span class="arithmatex">\(y_1 + 3y_2 \ge 4\)</span><br />
<span class="arithmatex">\(4y_1 - y_2 \ge 1\)</span><br />
<span class="arithmatex">\(y_2 \ge 3\)</span><br />
目标函数上界：<span class="arithmatex">\(y_1 + 3y_2\)</span>，优化目标是令其最小化。<br />
【例3】<br />
（1）原问题——生产计划问题<br />
<span class="arithmatex">\(max \space4x_1 + 3x_2\)</span><br />
<span class="arithmatex">\(s.t. \space 2x_1 + 3x_2 \le 24\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space 5x_1 + 2x_2 \le 26\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_1,x_2 \ge 0\)</span><br />
（2）设材料<span class="arithmatex">\(1, 2\)</span>的定价分别为<span class="arithmatex">\(y_1, y_2\)</span>，则对偶问题为：<br />
<span class="arithmatex">\(2y_1 + 5y_2 \ge 4\)</span><br />
<span class="arithmatex">\(3y_1 + 2 y_2 \ge 3\)</span><br />
优化目标：<span class="arithmatex">\(min \space 24y_1 + 26y_2\)</span><br />
（3）问题理解<br />
·原问题中，材料<span class="arithmatex">\(A, B\)</span>分别有<span class="arithmatex">\(24, 26\)</span>个单位的存量，设生产产品<span class="arithmatex">\(1,2\)</span>的产量分别为<span class="arithmatex">\(x_1, x_2\)</span>。<br />
·原问题中，生产一个单位的产品<span class="arithmatex">\(1\)</span>需要<span class="arithmatex">\(2\)</span>个单位的材料<span class="arithmatex">\(A\)</span>以及<span class="arithmatex">\(5\)</span>个单位的材料<span class="arithmatex">\(B\)</span>，盈利<span class="arithmatex">\(4\)</span>；生产一个单位的产品<span class="arithmatex">\(2\)</span>需要<span class="arithmatex">\(3\)</span>个单位的材料<span class="arithmatex">\(A\)</span>和<span class="arithmatex">\(2\)</span>个单位的材料<span class="arithmatex">\(B\)</span>，盈利<span class="arithmatex">\(3\)</span>。<br />
·对偶问题表示，现有一买家要向生产商购买全部材料<span class="arithmatex">\(A、B\)</span>，在保证生产商出售材料的盈利不低于自行用材料生产产品的盈利的前提下，最小化买家向生产商购买这些材料的成本。<br />
2.对偶问题定义<br />
<span class="arithmatex">\(\left[\begin{array}{c|c}
    Primal &amp; Dual \\
    max \space c^Tx &amp; min \space b^Ty\\
    a_i^Tx \le b_i &amp; y_i \ge 0 \\
    a_j^Tx \ge b_j &amp; y_i \le 0 \\
    a_K^Tx = b_k &amp; y_i\in(-\infty, +\infty) \\
    x_i \ge 0 &amp; A^T_iy \ge c_i \\  
    x_j \le 0 &amp; A_j^Ty \le c_j \\ 
    x_k \in (-\infty, \infty) &amp; A_j^Ty = c_j \\
\end{array}\right]\)</span><br />
【注】<br />
注意原问题的优化目标是最大化还是最小化，两种情况下对偶问题的条件转化方式不同。  </p>
<h5 id="_12">三、对偶的性质</h5>
<p>1.【定理1】对偶问题具有自反性。<br />
【证明】<br />
（1）原问题<span class="arithmatex">\((P)\)</span><br />
<span class="arithmatex">\(max \space c^Tx\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space Ax \le b\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space x \ge 0\)</span><br />
（2）对偶问题（给目标函数添加负号，仍然写成<span class="arithmatex">\(max\)</span>形式）<br />
<span class="arithmatex">\(max \space -b^Ty\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space -A^Ty \le -c^T\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space y \ge 0\)</span><br />
（3）对偶问题的对偶<br />
<span class="arithmatex">\(min \space -c^Tx\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space -Ax \ge -b\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space x \ge 0\)</span>  <br />
说明对偶问题的对偶恰好等价于原问题，对偶问题自反性成立。<br />
2.【定理2】<strong>弱对偶定理</strong>——刻画了对偶问题<strong>目标函数值之间的大小关系</strong>  <br />
设原问题<span class="arithmatex">\((P)\)</span>、对偶问题<span class="arithmatex">\((D)\)</span>的形式分别为：<br />
<span class="arithmatex">\((P)\)</span><br />
<span class="arithmatex">\(max \space c^Tx\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space Ax \le b\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space x \ge 0\)</span><br />
<span class="arithmatex">\((D)\)</span><br />
<span class="arithmatex">\(min \space b^Ty\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space A^Ty \ge c^T\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space y \ge 0\)</span><br />
若<span class="arithmatex">\((P)\)</span>和<span class="arithmatex">\((D)\)</span>均具有有限最优目标函数值，则<span class="arithmatex">\((P)\)</span>的任意一个可行解的目标函数值<span class="arithmatex">\(\le(D)\)</span>的任意一个可行解的目标函数值。<br />
【证明】<br />
（1）设<span class="arithmatex">\(x_0, y_0\)</span>分别是<span class="arithmatex">\((P), (D)\)</span>的任意一个可行解，则有：<br />
<span class="arithmatex">\(Ax_0 \le b\)</span>
<span class="arithmatex">\(y_0^TA \ge c\)</span>（由<span class="arithmatex">\(A^Ty_0 \ge c^T\)</span>转置而来）<br />
（2）第一式左乘<span class="arithmatex">\(y_0^T\)</span>得：<br />
<span class="arithmatex">\(y_0^TAx_0 \le y_0^Tb\)</span><br />
第二式右乘<span class="arithmatex">\(x_0\)</span>得：<br />
<span class="arithmatex">\(y^T_0Ax_0 \ge c^Tx_0\)</span><br />
（3）联立得：<br />
<span class="arithmatex">\(c^Tx_0 \le y_0^TAx_0 \le y_0^Tb\)</span>，即<span class="arithmatex">\(x_0\)</span>对应得目标函数值<span class="arithmatex">\(\le y_0\)</span>对应的目标函数值。<br />
3.【定理3】<strong>强对偶定理</strong>——刻画了对偶问题之间<strong>有限最优解的存在关系</strong>以及<strong>最优目标函数值的关系</strong><br />
设原问题<span class="arithmatex">\((P)\)</span>、对偶问题<span class="arithmatex">\((D)\)</span>的形式分别为：<br />
<span class="arithmatex">\((P)\)</span><br />
<span class="arithmatex">\(max \space c^Tx\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space Ax \le b\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space x \ge 0\)</span><br />
<span class="arithmatex">\((D)\)</span><br />
<span class="arithmatex">\(min \space b^Ty\)</span><br />
<span class="arithmatex">\(s.t. \space\space\space A^Ty \ge c^T\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space\space\space y \ge 0\)</span> 
若<span class="arithmatex">\((P)\)</span>具有有限最优解，则<span class="arithmatex">\((D)\)</span>也具有有限最优解，且二者最优目标函数值相等。<br />
【证明】（构造性证明）<br />
（1）考虑典则形式的单纯形表：<br />
<span class="arithmatex">\(\left[\begin{array}{c|cc|c}
     &amp; 0 &amp; c_B^T - c_N^TA_B^{-1}A_N &amp; -c_B^TA_B^{-1}b\\
    x_B &amp; I &amp; A_B^{-1}A_N &amp; A_B^{-1}b\\
\end{array}\right]\)</span><br />
（2）若原始问题最优（设其一个最优解为<span class="arithmatex">\(x\)</span>），则检验数向量<span class="arithmatex">\(\sigma = c_B^T - c_N^TA_B^{-1}A_N \le 0\)</span>，
即<span class="arithmatex">\(c_N^TA_B^{-1}A_N  \ge c_B^T\)</span><br />
（3）又因为<span class="arithmatex">\(c_B^TA_B^{-1}A_B = c_B^T\)</span>，与（2）中不等式合并得：<br />
<span class="arithmatex">\(c_B^TA_B^{-1}A \ge c^T\)</span><br />
观察对偶问题约束条件<span class="arithmatex">\(A^Ty \ge c^T\)</span>，令<span class="arithmatex">\(y^T = c_B^Ta_B^{-1}\)</span>，<br />
则<span class="arithmatex">\(y\)</span>满足对偶问题约束，并且目标函数值为<span class="arithmatex">\(c_B^TA_B^{-1}b\)</span>，目标函数值正好与目标函数值相同。<br />
（4）由弱对偶定理，若<span class="arithmatex">\((P)\)</span>和<span class="arithmatex">\((D)\)</span>均具有有限最优目标函数值，则<span class="arithmatex">\((P)\)</span>的任意一个可行解的目标函数值<span class="arithmatex">\(\le(D)\)</span>的任意一个可行解的目标函数值，因此此时<span class="arithmatex">\(x, y\)</span>分别是原问题和对偶问题的最优解。<br />
4.对偶单纯形法思想<br />
始终令检验数向量<span class="arithmatex">\(\sigma \le 0\)</span>，保证对偶可行，逐步迭代至原问题可行，则此时原问题的可行解就是原问题的最优解。  </p>
<h4 id="_13">应用运筹学基础 第五讲</h4>
<h5 id="_14">一、对偶单纯形法</h5>
<p><span class="arithmatex">\(\left[\begin{array}{c|cc|c}
     &amp; 0 &amp; c_B^T - c_N^TA_B^{-1}A_N &amp; -c_B^TA_B^{-1}b\\
    x_B &amp; I &amp; A_B^{-1}A_N &amp; A_B^{-1}b\\
\end{array}\right]\)</span><br />
1.单纯形法与对偶单纯形法基本思想<br />
（1）单纯形法：保证原始可行，通过选择变量进行入基、出基，逐步迭代至对偶可行。<br />
（2）对偶单纯形法：保证对偶可行，迭代至原始可行。<br />
2.对偶单纯形法举例<br />
【例1】
<span class="arithmatex">\(max \space z = -x_2 - 2 x_3\)</span><br />
<span class="arithmatex">\(s.t. \space x_1 + x_2 + x_3 = 5\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space 2x_2+x_3+x_4 = 5\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space -4x_2 - 6x_3 + x_5 = -9\)</span><br />
【解】<br />
（1）注意到<span class="arithmatex">\(\vec{x} = [5, 0, 0, 5, -9]^T\)</span>作为初始解，此时<strong>检验数均为负，保证了对偶可行</strong>，但是<strong>原始问题尚不可行</strong>。<br />
（2）初始解<span class="arithmatex">\(\vec{x} = [5, 0, 0, 5, -9]^T\)</span>对应的单纯形表如下：<br />
<span class="arithmatex">\(\left[\begin{array}{lcrrrr|r}
  \ &amp;  0 &amp; -1 &amp; -2 &amp; 0 &amp; 0 &amp; 0 \\
  x_1 &amp;  1 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 5 \\
  x_4 &amp;  0 &amp; 2 &amp; 1 &amp; 1 &amp; 0 &amp; 5 \\
  x_5 &amp;  0 &amp; -4 &amp; -6 &amp; 0 &amp; 1 &amp; -9 \\
\end{array}\right]\)</span><br />
（3）迭代的目的是：令<strong>取负值的变量<span class="arithmatex">\(x_5\)</span>出基</strong>，<strong>同时保证检验数全部不大于0</strong>（<strong>对偶可行</strong>）。观察最后一个约束，<span class="arithmatex">\(x_2, x_3\)</span>系数均为负数，可能作为入基变量。<br />
（4）比较<span class="arithmatex">\(\frac{检验数}{系数}\)</span>，选取<strong>比值最小</strong>的变量入基。注意到：<br />
<span class="arithmatex">\(\frac{-1}{-4} = \frac{1}{4}\)</span>，<span class="arithmatex">\(\frac{-2}{-6} = \frac{1}{3}\)</span>，因此选取<span class="arithmatex">\(x_2\)</span>作为入基变量。<br />
（5）让<span class="arithmatex">\(x_2\)</span>入基，进行<strong>旋转变换</strong>，使得<span class="arithmatex">\(x_2\)</span>对应的一列，<strong>有<span class="arithmatex">\(1\)</span>个<span class="arithmatex">\(1\)</span>和<span class="arithmatex">\(n-1\)</span>个<span class="arithmatex">\(0\)</span></strong>，则单纯形表变为：<br />
<span class="arithmatex">\(\left[\begin{array}{lcrrrr|r}
  \ &amp;  0 &amp; 0 &amp; -\frac{1}{2} &amp; 0 &amp; -\frac{1}{4} &amp; \frac{9}{4} \\
  x_1 &amp;  1 &amp; 0 &amp; -\frac{1}{2} &amp; 0 &amp; \frac{1}{4} &amp; \frac{11}{4} \\
  x_2 &amp;  0 &amp; 0 &amp; -2 &amp; 1 &amp; \frac{1}{2} &amp; \frac{1}{2} \\
  x_5 &amp;  0 &amp; 1 &amp; \frac{3}{2} &amp; 0 &amp; -\frac{1}{4} &amp; \frac{9}{4} \\
\end{array}\right]\)</span><br />
（6）观察上述单纯形表：此时<span class="arithmatex">\(\vec{x} = [\frac{11}{4}, \frac{1}{2}, 0, 0, \frac{9}{4}]\)</span>，<strong>原始可行</strong>；且检验数均不超过<span class="arithmatex">\(0\)</span>，<strong>对偶可行</strong>。故<strong>原始问题已迭代至最优解</strong>。<br />
3.对偶单纯形法——算法总结<br />
（1）针对初始单纯形表<strong>选取初始解，保证对偶可行</strong>，即检验数<span class="arithmatex">\(\vec{\sigma} \le 0\)</span>.<br />
（2）<strong>检验原始可行性</strong>，判断是否成立<span class="arithmatex">\(A_B^{-1}b \ge 0\)</span>.<br />
若<strong>成立</strong>，则<strong>原问题达到最优解</strong>；若不成立，进行（3）中的<strong>基变换</strong>。<br />
（3）基变换：让<span class="arithmatex">\(\tilde{A_i}b \lt 0\)</span>对应的变量<span class="arithmatex">\(x_i\)</span>出基，并选取变量<span class="arithmatex">\(j = argmin_{\tilde{a_{ij}} \lt 0}\frac{\sigma_j}{\tilde{a_{ij}}}\)</span>，即检验数为负，在出基变量对应方程的系数同样为负，并且<span class="arithmatex">\(\frac{检验数}{出基变量对应方程中系数}\)</span>比值最小的变量进行入基，这样才能保证方程的检验数<span class="arithmatex">\(\vec{\sigma} \le 0\)</span>，保证对偶可行。  </p>
<h5 id="-">二、互补-松弛定理</h5>
<p>1.对偶问题形式<br />
（1）原始问题<span class="arithmatex">\((P)\)</span><br />
<span class="arithmatex">\(max \space \vec{c}^T \vec{x}\)</span><br />
<span class="arithmatex">\(s.t. \space A \vec{x} \le \vec{b}\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space\vec{x} \ge 0\)</span><br />
（2）对偶问题<span class="arithmatex">\((D)\)</span><br />
<span class="arithmatex">\(min \space \vec{y}^T \vec{b}\)</span><br />
<span class="arithmatex">\(s.t. \space A^T \vec{y} \ge \vec{c}\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space\vec{y} \ge 0\)</span><br />
2.观察与构造<br />
（1）由原问题约束条件<span class="arithmatex">\(A\vec{x} \le \vec{b}\)</span>，两边同时左乘<span class="arithmatex">\(\vec{y}^T\)</span>，得到：<br />
<span class="arithmatex">\(\vec{y}^T A \vec{x} \le \vec{y}^T\vec{b}\)</span><br />
（2）由对偶问题约束条件<span class="arithmatex">\(A^T \vec{y} \ge \vec{c}^T\)</span>，两边先转置，再右乘<span class="arithmatex">\(\vec{x}\)</span>，可得：<br />
<span class="arithmatex">\(\vec{y}^TA\vec{x} \ge \vec{c}^T \vec{x}\)</span><br />
（3）上述两不等式联立，得到：<br />
<span class="arithmatex">\(\vec{c}^T \vec{x} \le \vec{y}^TA\vec{x} \le \vec{y}^T\vec{b}\)</span><br />
（4）假如<span class="arithmatex">\(\vec{x}, \vec{y}\)</span>分别是原问题和对偶问题的最优解，由于原问题和对偶问题的最优目标函数值相等，故上述不等式三项相等。<br />
分别针对第一、二个不等号移项可得：<br />
<span class="arithmatex">\((\vec{y}^TA - \vec{c}^T)\vec{x} = \vec{0}\)</span><br />
<span class="arithmatex">\(\vec{y}^T(A\vec{x} - \vec{b}) = \vec{0}\)</span><br />
2.【定理】互补松弛定理<br />
若<span class="arithmatex">\(\vec{x}, \vec{y}\)</span>分别是<span class="arithmatex">\((P), (D)\)</span>的一个可行解，则<span class="arithmatex">\(\vec{x}, \vec{y}\)</span>分别是<span class="arithmatex">\((P),(D)\)</span>的一个最优解，当且仅当:<br />
<span class="arithmatex">\((\vec{y}^TA - \vec{c}^T)\vec{x} = \vec{0}\)</span><br />
<span class="arithmatex">\(\vec{y}^T(A\vec{x} - \vec{b}) = \vec{0}\)</span><br />
3.【理解】已知对偶问题最优解<span class="arithmatex">\(\vec{y}\)</span>，根据<span class="arithmatex">\(\vec{y}\)</span><strong>各分量是否为<span class="arithmatex">\(0\)</span></strong>，以及<span class="arithmatex">\(\vec{y}\)</span>的<strong>各个不等式约束是否取等号</strong>，可以推测相应的<strong>原问题最优解<span class="arithmatex">\(\vec{x}\)</span>的下列性质</strong>：  <br />
（1）若已知对偶问题最优解<span class="arithmatex">\(\vec{y}\)</span>的第<span class="arithmatex">\(i\)</span>分量<span class="arithmatex">\(y_i \ne 0\)</span>，则与之相对应的原问题约束<span class="arithmatex">\(A_i\vec{x} - b_i = 0\)</span>.<br />
（2）若已知对偶问题约束<span class="arithmatex">\(\vec{y}^TA_j - \vec{c}_j \ne 0\)</span>，则相应的原问题第<span class="arithmatex">\(j\)</span>个变量<span class="arithmatex">\(x_j = 0\)</span>.  </p>
<h5 id="-_1">三、原始-对偶方法</h5>
<p>1.思路<br />
（1）从对偶问题<span class="arithmatex">\((D)\)</span>的一个可行解<span class="arithmatex">\(\vec{y}\)</span>开始，寻找原问题的可行解<span class="arithmatex">\(\vec{x}\)</span>，使得互补松弛条件得以满足：<br />
<span class="arithmatex">\((\vec{y}^TA - \vec{c}^T)\vec{x} = \vec{0}\)</span><br />
<span class="arithmatex">\(\vec{y}^T(A\vec{x} - \vec{b}) = \vec{0}\)</span><br />
（2）从<span class="arithmatex">\((D)\)</span>的一个可行解<span class="arithmatex">\(y\)</span>出发，寻找符合条件的<span class="arithmatex">\(x\)</span>。<br />
①<span class="arithmatex">\(x\)</span>是<span class="arithmatex">\((P)\)</span>的一个可行解。<br />
②检查下列互补-松弛条件方程组是否有解。<br />
<span class="arithmatex">\((\vec{y}^TA - \vec{c}^T)\vec{x} = \vec{0}\)</span><br />
<span class="arithmatex">\(\vec{y}^T(A\vec{x} - \vec{b}) = \vec{0}\)</span><br />
③若有解，则找到了原问题、对偶问题的最优解。<br />
④若无解，说明<span class="arithmatex">\(y\)</span>不是对偶问题的最优解，需要进行一些优化。<br />
2.对偶问题形式<br />
（1）原始问题<span class="arithmatex">\((P)\)</span>：<br />
<span class="arithmatex">\(min \space \vec{c}^T \vec{x}\)</span><br />
<span class="arithmatex">\(s.t. \space A\vec{x} = b\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space\space \vec{x} \ge \vec{0}\)</span><br />
（2）对偶问题<span class="arithmatex">\((D)\)</span>：<br />
<span class="arithmatex">\(max \space \vec{y}^T \vec{b}\)</span><br />
<span class="arithmatex">\(s.t. \space \vec{y}^T A \le \vec{c}^T\)</span><br />
3.设<span class="arithmatex">\(\vec{y}\)</span>是<span class="arithmatex">\((D)\)</span>的一个可行解，运行原始-对偶方法的目的是：寻求<span class="arithmatex">\(\vec{x}\)</span>，使得：<br />
<span class="arithmatex">\(A\vec{x} = \vec{b}\)</span><br />
<span class="arithmatex">\((A^T\vec{y} - \vec{c}^T)x = 0\)</span><br />
<span class="arithmatex">\(\vec{x} \ge \vec{0}\)</span><br />
4.指标集的引入<br />
引入指标集合<span class="arithmatex">\(J = \{j | y^T A_j = c_j\}\)</span>，则对于指标集之外的下标<span class="arithmatex">\(j\notin J\)</span>，必定成立<span class="arithmatex">\(x_j = 0\)</span>.<br />
【理解】指标集限定了哪些<span class="arithmatex">\(x_i\)</span>可能是基变量，指标集以外的下标对应的<span class="arithmatex">\(x_i\)</span>必定为<span class="arithmatex">\(0\)</span>，从而<strong>简化了原问题的求解</strong>。<br />
5.限定原问题和限定对偶问题<br />
（1）限定原问题<span class="arithmatex">\((RP)\)</span><br />
<span class="arithmatex">\(min \space \Sigma_{i = 1}^n \bar{x_i}\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{j \in J}a_ij x_j + \bar{x_i} = b_i\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_j \ge 0\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \bar{x_i} \ge 0\)</span><br />
【理解】<br />
①指标集以外的<span class="arithmatex">\(x_i\)</span>全为<span class="arithmatex">\(0\)</span>。<br />
②引入松弛向量，松弛变量之和是否能达到<span class="arithmatex">\(0\)</span>，决定了互补松弛条件方程组是否有解。<br />
（2）限定对偶问题<br />
<span class="arithmatex">\(max \space \tilde{y}^Tb\)</span><br />
<span class="arithmatex">\(s.t. \space \tilde{y}^TA_j \le 0\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \tilde{y_i} \le 1\)</span><br />
6.假设<span class="arithmatex">\(\tilde{y}\)</span>是<span class="arithmatex">\((DRP)\)</span>问题的最优解。<br />
（1）若<span class="arithmatex">\(\tilde{y}^Tb = 0\)</span>，则此时<span class="arithmatex">\(y\)</span>为<span class="arithmatex">\((D)\)</span>的最优解。<br />
（2）若<span class="arithmatex">\(\tilde{y}^Tb \gt 0\)</span>，则此时<span class="arithmatex">\(y\)</span>不是<span class="arithmatex">\((D)\)</span>的最优解，应对<span class="arithmatex">\(y\)</span>作改进<span class="arithmatex">\(y' = y + \theta \tilde{y}\)</span>，其中：<br />
<span class="arithmatex">\(\theta = min_{j: \tilde{y}^TA_j \gt 0}\frac{c_j - y^TA_j}{\tilde{y}^TA_j}\)</span>  </p>
<h5 id="-_2">四、最短路问题的原始-对偶算法</h5>
<p>1.有向图最短路问题——问题描述<br />
（1）作矩阵<span class="arithmatex">\(A\)</span>，横坐标代表各顶点，纵坐标表示各边，<span class="arithmatex">\((v_i, e_j)\)</span>取值为<span class="arithmatex">\(1\)</span>表示顶点<span class="arithmatex">\(v_i\)</span>向外发出边<span class="arithmatex">\(e_j\)</span>，<span class="arithmatex">\(-1\)</span>表示顶点<span class="arithmatex">\(v_i\)</span>接受边<span class="arithmatex">\(e_j\)</span>。<br />
（2）引进流量变量：<span class="arithmatex">\(f = [f_1, f_2, f_3, f_4, f_5]^T\)</span>，其中<span class="arithmatex">\(f_i \in \{0, 1\}\)</span>。<br />
（3）记<span class="arithmatex">\(P\)</span>为被选择的路径，则<span class="arithmatex">\(f_i = 0\)</span>表示<span class="arithmatex">\(e_i \notin P\)</span>，<span class="arithmatex">\(f_i = 1\)</span>表示<span class="arithmatex">\(e_i \in P\)</span>。<br />
（4）流量约束：<br />
设源点<span class="arithmatex">\(s\)</span>、汇点<span class="arithmatex">\(t\)</span>分别对应于前两个变量，则：<br />
<span class="arithmatex">\(Af = [1, -1, 0, \cdots, 0]^T\)</span>。<br />
（5）优化目标：<span class="arithmatex">\(min\Sigma_{e\in E} cost(e)f(e)\)</span><br />
【理解】<br />
<span class="arithmatex">\(Af = [1, -1, 0, \cdots, 0]^T\)</span>表示：源点只出不进，汇点恰好只进不出。其余点若被选取，则有进有出；若未被选取，则不进不出。<br />
2.有向图最短路问题——线性规划问题形式<br />
<span class="arithmatex">\(min\Sigma_{e\in E} cost(e)f(e)\)</span><br />
<span class="arithmatex">\(s.t. \space Af = [1, -1, 0, \cdots, 0]^T\)</span>
<span class="arithmatex">\(\space \space \space \space \space \space \space f \ge 0\)</span><br />
若去除汇点<span class="arithmatex">\(t\)</span>及与汇点相关的边的条件（即：只记录<span class="arithmatex">\(v_i\rarr t\)</span>的发出点<span class="arithmatex">\(v_i\)</span>，以及流量取值<span class="arithmatex">\(1\)</span>），则该问题变为：<br />
<span class="arithmatex">\(min\Sigma_{e\in E} cost(e)f(e)\)</span><br />
<span class="arithmatex">\(s.t. \space A'f = [1, 0, \cdots, 0]^T\)</span>
<span class="arithmatex">\(\space \space \space \space \space \space \space f \ge 0\)</span><br />
3.有向图最短路问题——对偶问题<br />
<span class="arithmatex">\(max \space y_s\)</span><br />
<span class="arithmatex">\(s.t. \space y_i-y_j \le c_{ij}\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space y_t = 0\)</span><br />
【理解】<br />
（1）设各顶点对应的<span class="arithmatex">\(y_u\)</span>与公路收费方的所获利润有关，并满足下列条件：<br />
·一是各有向路径<span class="arithmatex">\((i, j)\)</span>的收费不得超过上限<span class="arithmatex">\(c_{ij}\)</span>。<br />
·二是给定<span class="arithmatex">\(u\)</span>的后继结点<span class="arithmatex">\(u_1, \cdots, u_k\)</span>到汇点<span class="arithmatex">\(t\)</span>的收费<span class="arithmatex">\(y_{u_1}, \cdots, y_{u_k}\)</span>，以及从<span class="arithmatex">\(u\)</span>到<span class="arithmatex">\(u_1, \cdots, u_k\)</span>的有向路径的费用上限<span class="arithmatex">\(c_{u,u_1}, \cdots, c_{u, u_k}\)</span>，则<span class="arithmatex">\(y_k\)</span>不应超过<span class="arithmatex">\(min_{u = 1, 2, \cdots, k}(y_{u_i} + c_{u, u_i})\)</span>，即选择路径的人总是做出最廉价的选择，不会选择其他次优的路径。<br />
（2）<span class="arithmatex">\(y_t = 0\)</span>即为上述递归理解的起始条件。<br />
4.有向图最短路问题——限制对偶问题<br />
（1）针对对偶问题，引进<strong>与边相关</strong>的指标集<span class="arithmatex">\(J = \{(i, j)|y_i - y_j = c_{ij}\}\)</span>。<br />
（2）位于指标集中的边，即为被选中的最短路径的边；不在指标集中的边，即未被选中的边。<br />
（3）限制对偶问题的数学表达<br />
<span class="arithmatex">\(max \space \tilde{y}_s\)</span><br />
<span class="arithmatex">\(s.t. \space \tilde{y}_i - \tilde{y}_j \le 0, (i, j) \in J\)</span><br />
<span class="arithmatex">\(\space  \space  \space  \space  \space  \space  \space y_i \le 1, i \in V\)</span><br />
<span class="arithmatex">\(\space  \space  \space  \space  \space  \space  \space y_t = 0\)</span><br />
【理解】<br />
（1）<span class="arithmatex">\(\tilde{y}_i\)</span>的取值如下：<br />
若<span class="arithmatex">\(i\)</span>到<span class="arithmatex">\(t\)</span>存在位于指标集<span class="arithmatex">\(J\)</span>中的通路，则<span class="arithmatex">\(\tilde{y}_i = 0\)</span>；若<span class="arithmatex">\(i\)</span>到<span class="arithmatex">\(t\)</span>不存在位于指标集<span class="arithmatex">\(J\)</span>中的通路，则可取<span class="arithmatex">\(\tilde{y}_i = 1\)</span>。<br />
（2）若最优值<span class="arithmatex">\(y_s^* = 1\)</span>，说明对偶非最优；若<span class="arithmatex">\(y_s^* = 0\)</span>，说明对偶最优。<br />
（3）使用原始-对偶算法的目的：按照某种规则，不断扩展可以到达汇点<span class="arithmatex">\(t\)</span>的顶点集合，直到源点<span class="arithmatex">\(s\)</span>进入该集合，迭代终止。  </p>
<h4 id="_15">应用运筹学基础 第六讲</h4>
<h5 id="-_3">一、最短路问题的原始-对偶算法</h5>
<p>1.线性规划模型<br />
（1）原始问题<span class="arithmatex">\((P)\)</span><br />
<span class="arithmatex">\(min\Sigma_{e\in E} cost(e)f(e)\)</span><br />
<span class="arithmatex">\(s.t. \space A'f = [1, 0, \cdots, 0]^T\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space f \ge 0\)</span><br />
（2）对偶问题<span class="arithmatex">\((D)\)</span><br />
<span class="arithmatex">\(max \space y_s\)</span><br />
<span class="arithmatex">\(s.t. \space y_i-y_j \le c_{ij}\)</span><br />
<span class="arithmatex">\(\space\space\space\space\space\space\space y_t = 0\)</span><br />
（3）限制对偶问题<span class="arithmatex">\((DRP)\)</span><br />
<span class="arithmatex">\(max \space \tilde{y}_s\)</span><br />
<span class="arithmatex">\(s.t. \space \tilde{y}_i - \tilde{y}_j \le 0, (i, j) \in J, J = \{(i, j)|y_i - y_j = c_{ij}\}\)</span><br />
<span class="arithmatex">\(\space  \space  \space  \space  \space  \space  \space y_i \le 1, i \in V\)</span><br />
<span class="arithmatex">\(\space  \space  \space  \space  \space  \space  \space y_t = 0\)</span><br />
2.理解<br />
（1）若从<span class="arithmatex">\(s\)</span>到<span class="arithmatex">\(t\)</span>有一条路径，则<span class="arithmatex">\((DRP)\)</span>中，对应于路径上各顶点的<span class="arithmatex">\(y_i\)</span>都为<span class="arithmatex">\(0\)</span>。<br />
（2）设<span class="arithmatex">\((DRP)\)</span>的最优解为<span class="arithmatex">\(\tilde{y}_s\)</span>。<br />
·若<span class="arithmatex">\(\tilde{y}_s = 0\)</span>，则<span class="arithmatex">\((D)\)</span>为最优；<br />
·若<span class="arithmatex">\(\tilde{y}_s = 1\)</span>，则<span class="arithmatex">\((D)\)</span>可以进行提升，令<span class="arithmatex">\(y' = y + \theta \tilde{y_s}\)</span>，参数<span class="arithmatex">\(\theta\)</span>将在后面讨论。<br />
（3）提升条件：<span class="arithmatex">\(y_i' - y_j' \le c_{ij}\)</span>，即<span class="arithmatex">\((y_i - y_j) + \theta(\tilde{y}_i - \tilde{y}_j) \le c_{ij}\)</span>。<br />
·若<span class="arithmatex">\((i, j) \in J\)</span>，则原来已有<span class="arithmatex">\(y_i - y_j = c_{ij}\)</span>，且<span class="arithmatex">\(\tilde{y}_i - \tilde{y}_j \le 0\)</span>，上式成立。<br />
·若<span class="arithmatex">\((i, j)\notin J\)</span>，则原来成立<span class="arithmatex">\(y_i - y_j \lt c_{ij}\)</span>，且<span class="arithmatex">\(\theta_{max} = \frac{c_{ij} - y_i - y_j}{\tilde{y}_i - \tilde{y}_j}\)</span><br />
当<span class="arithmatex">\(\tilde{y}_i = 1,\tilde{y}_j = 0\)</span>时，有<span class="arithmatex">\(\theta_{max} = c_{ij} - (y_i - y_j)\)</span>。<br />
·故<span class="arithmatex">\(\theta = min_{(i,j) \notin J} (c_{ij} - (y_i - y_j))\)</span><br />
3.若<span class="arithmatex">\((i, j)\in J\)</span>，则<span class="arithmatex">\(y_i - y_j = c_{ij}\)</span>，下次迭代后，由于<span class="arithmatex">\(\tilde{y}_i = \tilde{y}_j = 0\)</span>，故<span class="arithmatex">\(y_i' - y_j' = c_{ij}\)</span>，表明：<strong>指标集<span class="arithmatex">\(J\)</span>只进不出</strong>。<br />
4.最短路问题举例<br />
【例1】运用原始-对偶算法，寻求下列有向图中的最短路径。  <br />
<img alt="" src="../assets/NA/A.JPG" />
【解答】<br />
（1）考虑该问题的对偶问题，设<span class="arithmatex">\(y_i\)</span>是顶点<span class="arithmatex">\(i\)</span>到汇点<span class="arithmatex">\(t\)</span>，按照上一讲“理解”部分所述规则下的最大盈利；左上、左下、右上、右下角的顶点编号依次为<span class="arithmatex">\(1, 2, 3, 4\)</span>。<br />
（2）寻找初始可行解：<span class="arithmatex">\(y = [0, 0, 0, 0, 0]^T\)</span>。<br />
此时，容许指标集<span class="arithmatex">\(J = \emptyset\)</span>。<br />
故令<span class="arithmatex">\(\tilde{y} = [1, 1, 1, 1, 1]^T\)</span>。<br />
（3）考虑提升：<span class="arithmatex">\(\theta_{max} = 2\)</span>，原因是，从各顶点直接到汇点的边中，最小的费用上限为<span class="arithmatex">\(c_{3, t} = 2\)</span>。<br />
此时<span class="arithmatex">\(y' = [2, 2, 2, 2, 2]^T,J = \{e_{3, t}\}\)</span>。<br />
（4）此时，顶点<span class="arithmatex">\(3\)</span>位于指标集路径中，故<span class="arithmatex">\(\tilde{y} = [1, 1, 1, 0, 1]\)</span>。<br />
<span class="arithmatex">\(\theta_{max} = 2\)</span>，对应于边<span class="arithmatex">\(e_{4, 3}\)</span>。<br />
<span class="arithmatex">\(y' = y+\theta \tilde{y} = [4, 4, 4, 2, 4]^T\)</span><br />
<span class="arithmatex">\(J = \{e_{4, 3}, e_{3, t}\}\)</span><br />
（5）<span class="arithmatex">\(\tilde{y} = [1, 1, 1, 0, 0]^T\)</span>。<br />
<span class="arithmatex">\(\theta_{max} = 1\)</span>，对应于边<span class="arithmatex">\(e_{2, 4}\)</span>。<br />
<span class="arithmatex">\(y' = y+\theta \tilde{y} = [5, 5, 5, 2, 4]^T\)</span><br />
<span class="arithmatex">\(J = \{e_{1, 3}, e_{2, 4}, e_{4, 3}, e_{3, t}\}\)</span><br />
（6）<span class="arithmatex">\(\tilde{y} = [1, 0, 0, 0, 0]^T\)</span>。<br />
<span class="arithmatex">\(\theta_{max} = 1\)</span>，对应于边<span class="arithmatex">\(e_{s, 2}\)</span>。<br />
<span class="arithmatex">\(y' = y+\theta \tilde{y} = [6, 5, 5, 2, 4]^T\)</span><br />
<span class="arithmatex">\(J = \{e_{s, 2}, e_{1, 3}, e_{2, 4}, e_{4, 3}, e_{3, t}\}\)</span><br />
（7）<span class="arithmatex">\(\tilde{y} = [0, 0, 0, 0, 0]^T\)</span>，<span class="arithmatex">\(y_s = 6\)</span>即最短路对应的总开销，最短路径即<span class="arithmatex">\(e_{s, 2}, e_{2, 4}, e_{4, 3}, e_{3, t}\)</span>。  </p>
<h5 id="_16">二、整数线性规划——举例</h5>
<p>1.最大权匹配问题<br />
（1）给定无向图<span class="arithmatex">\(G = (V, E)\)</span>，以及权函数<span class="arithmatex">\(w: E \rightarrow Z ^+\)</span>。<br />
（2）问题描述<br />
<span class="arithmatex">\(max \space \Sigma_{e\in E}w_e \chi_e\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{u \in e}\chi_e \le 1, \forall u \in V\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \chi_e \in \{0, 1\}\)</span><br />
（3）若<span class="arithmatex">\(e \in M\)</span>，则<span class="arithmatex">\(\chi_e = 1\)</span>；若<span class="arithmatex">\(e \notin M\)</span>，则<span class="arithmatex">\(\chi_e = 0\)</span>。<br />
2.背包问题<br />
（1）设背包的容量为<span class="arithmatex">\(C\)</span>，<span class="arithmatex">\((s_i, p_i)\)</span>表示第<span class="arithmatex">\(i\)</span>个物品占用容积及其利润。<br />
（2）问题描述<br />
<span class="arithmatex">\(max \space \Sigma_{i = 1}^n p_i x_i\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{i = 1}^n s_ix_i \le C\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_i \in \{0, 1\}\)</span> <br />
（3）二维背包问题：添加约束<span class="arithmatex">\(\Sigma_{i = 1}^n t_i x_i \le D\)</span>。<br />
（4）多个背包问题<br />
<span class="arithmatex">\(max \space \Sigma_{j = 1}^m \Sigma_{i = 1}^n p_i x_{ij}\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{i = 1}^n x_{ij}s_i \le C_j\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_{ij} \in \{0, 1\}\)</span><br />
（5）变式：各类物品都有无数份可供选取，则<span class="arithmatex">\(x_{ij} \in N\)</span>。<br />
3.装箱问题<br />
（1）设有物品<span class="arithmatex">\(a_1, \cdots, a_n\)</span>，各箱子容量均为<span class="arithmatex">\(C\)</span>。<br />
（2）引入变量<span class="arithmatex">\(y_i\)</span>，表示各箱子是否被使用。<br />
（3）问题描述<br />
<span class="arithmatex">\(min \space \Sigma_{i = 1}^n y_i\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{i = 1}^n x_{ij} = 1\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \Sigma_{j = 1}^m x_{ij} a_j \le C_i y_i\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_{ij}, y_i \in \{0, 1\}\)</span>
4.旅行商问题<br />
（1）给定<span class="arithmatex">\(G = (V, E)\)</span>，各边费用<span class="arithmatex">\(c: E \rightarrow Z^+，V = \{0, 1, \cdots, n\}\)</span>，目的是寻找一个哈密顿图，遍历各顶点并返回源点，使开销之和最小。<br />
（2）约束条件限制：各边开销<span class="arithmatex">\(c\)</span>满足三角不等式。<br />
（3）引入变量<span class="arithmatex">\(x_{ij} \in \{0, 1\}\)</span>，表明各边是否被选中。<br />
（4）问题描述<br />
<span class="arithmatex">\(min \space \Sigma_{(i, j)\in E}c_{ij}x_{ij}\)</span><br />
<span class="arithmatex">\(s.t. \space  \Sigma_{i = 1}^n x_{ij} = 1, j = 0, 1, \cdots, n\)</span>（每个顶点恰好发出一边）<br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \Sigma_{j = 1}^n x_{ij} = 1, i = 0, 1, \cdots, n\)</span>（每个顶点恰好接受一边）<br />
（5）上述约束条件不充分，应引入辅助变量<span class="arithmatex">\(u_i, i = 1, 2, \cdots, n\)</span>，以及额外的约束条件：<br />
<span class="arithmatex">\(u_i - u_j + nx_{ij} \le n - 1, 1 \le i \ne j \le n\)</span><br />
①该约束条件可以排除所有非哈密顿圈。若某圈中不含点<span class="arithmatex">\(O\)</span>（下标为<span class="arithmatex">\(0\)</span>），则针对圈中的所有边（设共有<span class="arithmatex">\(k\)</span>条边）进行求和，可得<span class="arithmatex">\(kn \le k(n - 1) <span class="arithmatex">\(，因此所有非哈密顿圈都不完全满足上述约束条件。  
②上述约束条件不会“误伤”任何哈密顿圈。针对哈密顿圈，辅助变量\)</span>u\)</span>的一种合理构造是：<span class="arithmatex">\(u_i = i, i = 1, 2, \cdots, n\)</span>。此时，由于边<span class="arithmatex">\(e_{1, n}\)</span>未被选中，即<span class="arithmatex">\(x_{1, n} = 0\)</span>，故针对哈密顿圈中的所有边，对上述不等式求和得到：<br />
<span class="arithmatex">\(LHS = (n - 1) + (n - 1)(n - 1) = n(n - 1)\)</span><br />
<span class="arithmatex">\(RHS = n(n - 1)\)</span><br />
因此<span class="arithmatex">\(LHS \le RHS\)</span>恒成立，即任何哈密顿圈不会被该约束条件“误伤”。  </p>
<h5 id="_17">三、求解整数线性规划的基本框架</h5>
<p>1.两个基本框架<br />
（1）利用线性规划的松弛方法。<br />
（2）利用整数性质，进行“舍入”。<br />
2.线性规划存在整数最优解的条件<br />
（1）考虑<span class="arithmatex">\(A_Bx_B + A_Nx_N = b\)</span>，<span class="arithmatex">\(x_B = A_B^{-1}b\)</span>即为决定整数解的条件。<br />
（2）一个充分条件：若所有基本可行解都是整数，则线性规划问题<span class="arithmatex">\(\Leftrightarrow\)</span>整数规划问题。<br />
（3）注意事项：<span class="arithmatex">\(A_B ^{-1} = \frac{A_B^*}{|A_B|}\)</span>，从而可以将对<span class="arithmatex">\(A_B^{-1}\)</span>的研究，转换为对<span class="arithmatex">\(A_B\)</span>及其伴随矩阵<span class="arithmatex">\(A_B^*\)</span>的研究。<br />
3.【定义1】<strong>全单位模（幺模）矩阵</strong><br />
（1）若矩阵<span class="arithmatex">\(A\)</span>的行列式<span class="arithmatex">\(|A| = \pm 1\)</span>，称<span class="arithmatex">\(A\)</span>为<strong>单位模矩阵</strong>。<br />
（2）若<span class="arithmatex">\(|A|\)</span>的<strong>所有非奇异子方阵都是单位模矩阵</strong>，则称<span class="arithmatex">\(A\)</span>为<strong>全单位模矩阵</strong>。<br />
4.【定理1】若<span class="arithmatex">\(A\)</span>为全单位模矩阵，则<span class="arithmatex">\((A, I)\)</span>也是全单位模矩阵。<br />
5.设矩阵<span class="arithmatex">\(A\)</span>中的元素只有<span class="arithmatex">\(0, \pm 1\)</span>，且<span class="arithmatex">\(A\)</span>中每列的非零元素至多<span class="arithmatex">\(2\)</span>个，并且<span class="arithmatex">\(A\)</span>的行向量可以分成<span class="arithmatex">\(2\)</span>个不相交的集合<span class="arithmatex">\(I, J\)</span>，分划规则为：<br />
（1）若某列有<span class="arithmatex">\(2\)</span>个<span class="arithmatex">\(1\)</span>，或<span class="arithmatex">\(2\)</span>个<span class="arithmatex">\(-1\)</span>，则相应行分属<span class="arithmatex">\(I, J\)</span>。<br />
（2）若某列有<span class="arithmatex">\(1\)</span>个<span class="arithmatex">\(1\)</span>，<span class="arithmatex">\(1\)</span>个<span class="arithmatex">\(-1\)</span>，则相应行同属于<span class="arithmatex">\(I\)</span>，或同属于<span class="arithmatex">\(J\)</span>。<br />
此时，称<span class="arithmatex">\(A\)</span>是全单位模矩阵。<br />
6.举例<br />
（1）有向图的关联矩阵为全单位模矩阵。<br />
（2）二部图的关联矩阵为全单位模矩阵。  </p>
<h4 id="_18">应用运筹学基础 第七讲</h4>
<h5 id="gomory">一、整数规划基本算法——<code>Gomory</code>割平面法</h5>
<p>1.基本思想<br />
（1）将整数规划问题松弛为线性规划问题，从而扩大可行域。<br />
（2）“切割”出一个闭包（不一定是整数闭包），但是令整数解保留在该闭包中，并将最优解“切割”为凸多面体的极点。<br />
2.取整舍入步骤及其思想<br />
（1）行变换后，各方程组的形式为：<span class="arithmatex">\(x_i + \Sigma_{k = m+1}^n \bar{a}_{ik}x_k = \bar{b}_i \cdots (1)\)</span>，其中<span class="arithmatex">\(x_1, \cdots, x_m\)</span>为基变量，<span class="arithmatex">\(x_{m+1}, \cdots, x_n\)</span>为非基变量。  <br />
（2）先对各非基变量的系数<span class="arithmatex">\(\bar{a}_{ik}\)</span>进行向下取整，并将等式约束变为不等式约束，再对右侧常数进行向下取整：<span class="arithmatex">\(x_i + \Sigma_{k = m+1}^n \lfloor \bar{a}_{ik} \rfloor x_k \le \lfloor \bar{b}_i \rfloor \cdots  (2)\)</span><br />
（3）上述两不等式约束相减得：<span class="arithmatex">\(\Sigma_{k = m+1}^n (\bar{a}_{ik} - \lfloor \bar{a}_{ik} \rfloor)x_{k} \ge b_i - \lfloor \bar{b}_i \rfloor\)</span>，即为针对整数线性规划的约束。  </p>
<h5 id="_19">二、整数规划基本算法——分枝定界法</h5>
<p>1.问题形式<br />
<span class="arithmatex">\(min \space c^Tx\)</span><br />
<span class="arithmatex">\(s.t. \space Ax = b\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x \ge 0, x \in Z\)</span><br />
2.算法步骤<br />
（1）解决<strong>线性规划问题</strong>，得到<span class="arithmatex">\(x_i = \bar{b}_i \gt 0\)</span>，此时<span class="arithmatex">\(x_i\)</span>不一定是整数。<br />
（2）分枝<br />
·令<span class="arithmatex">\(x_i \le \lfloor \bar{b}_i \rfloor\)</span>，作为一个分枝<span class="arithmatex">\(LP_1\)</span>的约束。<br />
·令<span class="arithmatex">\(x_i \gt \lfloor \bar{b}_i \rfloor\)</span>，作为另一分枝<span class="arithmatex">\(LP_2\)</span>的约束。<br />
（3）定界（针对最小化问题）<br />
·下界：初始化为线性规划问题的最小值，原因是线性规划问题的最小值<span class="arithmatex">\(\le\)</span>整数规划问题的最小值；最后需要变为整数规划各“叶子”问题的最小值。<br />
·上界：当前整数线性规划的最小值。<br />
（4）分枝的可能情形<br />
·某一枝算出整数解，或无可行解——明枝<br />
·某一枝当前的目标函数值<span class="arithmatex">\(\ge\)</span>当前上界——枯枝<br />
·其余枝——活枝<br />
（4）针对各个非整数分量<span class="arithmatex">\(x_i\)</span>迭代进行分枝、定界，直到只剩明枝、枯枝为止。<br />
【例1】<span class="arithmatex">\(max \space z = x_1 + x_2\)</span><br />
<span class="arithmatex">\(s.t. \space -4x_1 + 2x_2 \le -1\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space 4x_1 + 2x_2 \le 11\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space -2x_2 \le -1\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_1, x_2 \in Z\)</span><br />
【解】<br />
（1）由图解法可得线性规划问题的最优解<span class="arithmatex">\(x = [1.5, 2.5]^T\)</span>，最优目标函数值为<span class="arithmatex">\(4\)</span>。<br />
（2）根据<span class="arithmatex">\(x_1\)</span>取值进行分枝<br />
·<span class="arithmatex">\(x_1 \le 1\)</span>：<span class="arithmatex">\(x = [1, 1.5]^T\)</span>时，<span class="arithmatex">\(z_{max} = 2.5\)</span><br />
·<span class="arithmatex">\(x_1 \ge 2\)</span>：<span class="arithmatex">\(x = [2, 1.5]^T\)</span>时，<span class="arithmatex">\(z_{max} = 3.5\)</span><br />
（3）由于<span class="arithmatex">\(x_1 \ge 2\)</span>的最优目标函数值更大，故保留第二分枝，第一分枝成为枯枝，进行剪枝。<br />
（4）根据<span class="arithmatex">\(x_2\)</span>取值进行二次分枝<br />
·<span class="arithmatex">\(x_2 \le 1\)</span>：<span class="arithmatex">\(x = [2.25, 1]^T\)</span>时，<span class="arithmatex">\(z_{max} = 3.25\)</span><br />
·<span class="arithmatex">\(x_2 \ge 2\)</span>：无解<br />
（5）根据<span class="arithmatex">\(x_1\)</span>取值进行三次分枝<br />
·<span class="arithmatex">\(x_1 \le 2\)</span>：<span class="arithmatex">\(x = [2, 1]^T\)</span>时，<span class="arithmatex">\(z_{max} = 3\)</span><br />
·<span class="arithmatex">\(x_1 \ge 3\)</span>：无解<br />
（6）综上，<span class="arithmatex">\(x = [2, 1]^T\)</span>是整数线性规划的最优解，对应最优目标函数值为<span class="arithmatex">\(3\)</span>。  </p>
<h5 id="_20">三、近似比</h5>
<p>1.近似比记号<br />
（1）<span class="arithmatex">\(I\)</span>：某类最小化/最大化问题的一个实例<br />
（2）<span class="arithmatex">\(A\)</span>：问题<span class="arithmatex">\(I\)</span>的一个多项式时间近似算法<br />
2.【定义1】近似比<br />
（1）最小化问题近似比：<span class="arithmatex">\(\rho = inf\{r | A(I) \le r OPT(I), \forall I\}\)</span><br />
（2）最小化问题近似比等价定义：<span class="arithmatex">\(\rho = sup_I\frac{A(I)}{OPT(I)}\)</span><br />
3.近似程度的区分  <br />
（1）<code>PTAS(Polynomial Time Approximation Method)</code><br />
<span class="arithmatex">\(\forall \epsilon \gt 0, A_\epsilon(I) \le (1+\epsilon)OPT(I), T = O(|I|^{f(\frac{1}{\epsilon})})\)</span><br />
（2）<code>FPTAS</code><br />
<span class="arithmatex">\(T = O(|I|^{O(1)}(\frac{1}{\epsilon})^n)\)</span><br />
（3）<code>EPTAS</code><br />
<span class="arithmatex">\(T = O(|I|^{O(1)}f(\frac{1}{\epsilon}))\)</span>  </p>
<h5 id="_21">四、基于线性规划的近似算法</h5>
<p>1.算法基本框架<br />
（1）整数规划松弛为线性规划：<span class="arithmatex">\(ILP \rightarrow_{relaxation} LP\)</span><br />
（2）最优解<br />
·整数线性规划的实际最优解：<span class="arithmatex">\(c^*_{ILP}\)</span><br />
·线性规划的实际最优解：<span class="arithmatex">\(c^*_{LP}\)</span><br />
·对<span class="arithmatex">\(c^*_{LP}\)</span>进行舍入操作，得到整数线性规划的近似解<span class="arithmatex">\(c_{ILP}\)</span>。<br />
（3）近似比：<span class="arithmatex">\(\frac{c_{ILP}}{c^*_{ILP}}\)</span><br />
（4）实际上，<span class="arithmatex">\(c^*_{ILP}\)</span>是未知的，但是可以关注不等式：<span class="arithmatex">\(\frac{c^*_{ILP}}{c^*_{LP}} \le \frac{c_{ILP}}{c^*_{ILP}} \le \frac{c_{ILP}}{c^*_{LP}}\)</span><br />
（5）整数间隙——整数规划与线性规划最优解之比<br />
<span class="arithmatex">\(\frac{c^*_{ILP}}{c^*_{LP}}\)</span><br />
2.基于线性规划的近似算法——背包问题<br />
（1）问题描述<br />
<span class="arithmatex">\(max \space \Sigma_{i = 1}^n x_i p_i\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{i = 1}^mc_ix_i \le C\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_i \in \{0, 1\}\)</span><br />
（2）若先解线性规划问题，再进行舍入，则整数间隙<span class="arithmatex">\(\frac{c^*_{ILP}}{c^*_{LP}} \ge 2\)</span><br />
【例2】设有两个物品<span class="arithmatex">\((0.5C, 0.5p+0.5), (C, P)\)</span><br />
（1）整数规划最大获利为<span class="arithmatex">\(P\)</span><br />
（2）线性规划最大获利为<span class="arithmatex">\(P + 0.5\)</span><br />
（3）若令<span class="arithmatex">\(P \rightarrow 0\)</span>，则整数间隙$ \rarr + \infin$<br />
3.基于线性规划的近似算法——负载均衡问题<br />
（1）问题背景<br />
设有<span class="arithmatex">\(m\)</span>台机器，<span class="arithmatex">\(n\)</span>个任务，<span class="arithmatex">\(P_{ij}\)</span>是第<span class="arithmatex">\(j\)</span>个任务安排至第<span class="arithmatex">\(i\)</span>个机器时占用的资源。<br />
（2）问题描述<br />
<span class="arithmatex">\(min \space\)</span><br />
<span class="arithmatex">\(s.t. \space \Sigma_{i = 1}^mx_{ij} = 1\)</span><br />
<span class="arithmatex">\(\space \space \space \space \space \space \space \Sigma_{j = 1}^n x_{ij}p_{ij} \le t\)</span><br />
<span class="arithmatex">\(x_{ij} \in \{0, 1\}\)</span><br />
（3）解决方法<br />
·最优解取值范围：<span class="arithmatex">\(0 \le t^* \le \Sigma p_{ij}\)</span><br />
·通过二分法，枚举猜想<span class="arithmatex">\(t^*\)</span><br />
·若某工作方案的总时间<span class="arithmatex">\(t \lt t^*\)</span>，则<span class="arithmatex">\(t^*\)</span>猜大了。<br />
·若无解，则<span class="arithmatex">\(t^*\)</span>猜小了。<br />
·二分迭代，逐步缩小范围，直至恰好猜出一个整数解。  </p>
<h4 id="_22">应用运筹学基础 第十讲</h4>
<h5 id="_23">一、两类基本优化问题</h5>
<p>1.极大化问题<br />
（1）数学描述<br />
给定独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>、费用函数<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span>，求<span class="arithmatex">\(X \in F\)</span>，使得<span class="arithmatex">\(c(X)\)</span>最大。<br />
（2）理解<br />
求解目标：权重最大的独立集。 
[注]隐含信息：权重最大的独立集必定是基。   </p>
<p>2.极小化问题<br />
（1）数学描述
给定独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>、费用函数<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span>，求<strong>基</strong><span class="arithmatex">\(B \in F\)</span>，使得<span class="arithmatex">\(c(B)\)</span>最小。<br />
（2）理解<br />
求解目标：权重最小的<strong>极大</strong>独立集。  </p>
<h5 id="_24">二、若干优化问题</h5>
<p>[注]先直接理解问题中“基”的概念，再思考“独立集”是什么。往往一个可行解对应于一个基，且<span class="arithmatex">\(\mathscr{F}\)</span>中每个集合必定是某个基的子集。  </p>
<p>1.最小生成树问题<br />
（1）已知条件<br />
·无向图<span class="arithmatex">\(G = (V, E)\)</span><br />
（2）独立系统<br />
·<span class="arithmatex">\(E = E(G)\)</span><br />
·<span class="arithmatex">\(F = \{X \in E| X是森林\}\)</span><br />
（3）权重函数
·<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span><br />
[注]<span class="arithmatex">\(E\)</span>中每一个<strong>基</strong>，都是一棵<strong>生成树</strong>。  </p>
<p>2.最短路径问题<br />
（1）已知条件<br />
·无向图<span class="arithmatex">\(G = (V, E)\)</span><br />
（2）独立系统<br />
·<span class="arithmatex">\(E = E(G)\)</span><br />
·<span class="arithmatex">\(F = \{X | X是s \rightarrow t某条道路的子集\}\)</span><br />
（3）权重函数<br />
·<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span>  </p>
<p>3.最大权匹配问题<br />
（1）已知条件<br />
·无向图<span class="arithmatex">\(G = (V, E)\)</span><br />
（2）独立系统<br />
·<span class="arithmatex">\(E = E(G)\)</span><br />
·<span class="arithmatex">\(F = \{X | X \subset E(G)，且X中各边无公共顶点\}\)</span><br />
（3）权重函数
·<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span>  </p>
<p>4.顶点覆盖问题<br />
[注]选择权重之和最小的顶点集，以覆盖<span class="arithmatex">\(E\)</span>中的所有边。  <br />
（1）已知条件<br />
·无向图<span class="arithmatex">\(G = (V, E)\)</span><br />
（2）独立系统<br />
·<span class="arithmatex">\(E = V(G)\)</span><br />
·<span class="arithmatex">\(F = \{X | X \subset V,且X中任一顶点取出后，均无法覆盖E\}\)</span><br />
[注]上述<span class="arithmatex">\(X\)</span>的等价含义：<span class="arithmatex">\(X\)</span>是某个极小顶点覆盖的子集。<br />
（3）权重函数
·<span class="arithmatex">\(c: V \rightarrow \mathbb{R}^{+}\)</span>  </p>
<p>5.装箱问题<br />
（1）假设<br />
对于任意一个单一的箱子，可行的装箱方案有<span class="arithmatex">\(M\)</span>种，即<span class="arithmatex">\(\{t_1, t_2, \cdots, t_M\}\)</span>。<br />
（2）装箱问题的任一解，由若干箱子的<code>patterns</code>组成，使得每一个<code>item</code>恰好出现在唯一一个选中的<code>pattern</code>中，该解记作<code>configuration</code>。<br />
（3）独立系统
·<span class="arithmatex">\(E = \{t_1, \cdots, t_M\}\)</span><br />
[注]恰好是<strong>所有可行方案构成的集合</strong>。<br />
·<span class="arithmatex">\(F = \{P | P是某个configuration的子集\}\)</span><br />
（4）权重函数<br />
·<span class="arithmatex">\(c: E \rightarrow 1\)</span> </p>
<h5 id="_25">三、贪心算法</h5>
<p>[注]下列涉及的优胜法、劣汰法有几点注意事项：<br />
（1）先对元素的权重进行降序排序，再按此顺序，对元素进行逐个加入或逐个剔除。<br />
（2）优胜法用于极小化问题、劣汰法用于极大化问题，都可能带来无限坏的结果。<br />
（3）先对元素进行降序排序，是离线算法。   </p>
<p>1.优胜(<code>Best-in</code>)法——解决<strong>极大化</strong>问题的贪心算法<br />
（1）对<span class="arithmatex">\(E\)</span>中元素按照权重进行<strong>降序</strong>排序，使得：<span class="arithmatex">\(c(e_1) \ge c(e_2) \ge \cdots \ge c(e_n)\)</span>。<br />
（2）初始化解集<span class="arithmatex">\(F = \emptyset\)</span>。<br />
（3）对<span class="arithmatex">\(i = 1, 2, \cdots, n\)</span>，若<span class="arithmatex">\(F \cup \{e_i\} \in F\)</span>，则令<span class="arithmatex">\(F = F \cup \{e_i\}\)</span>。<br />
[理解]如果添加当前权重最大元素后，解集仍为独立集，则该元素可以加入解集中。  </p>
<p>2.劣汰(<code>Worst-out</code>)法——解决<strong>极小化</strong>问题的贪心算法<br />
（1）对<span class="arithmatex">\(E\)</span>中元素按照权重进行<strong>降序</strong>排序，使得：<span class="arithmatex">\(c(e_1) \ge c(e_2) \ge \cdots \ge c(e_n)\)</span>。<br />
（2）初始化解集<span class="arithmatex">\(F = E\)</span>。<br />
（3）对<span class="arithmatex">\(i = 1, 2, \cdots, n\)</span>，若<span class="arithmatex">\(F \backslash \{e_i\}\)</span>包含<strong>某个基</strong>，则令<span class="arithmatex">\(F = F \backslash \{e_i\}\)</span>。<br />
[理解]如果去除当前权重最大的元素后，解集仍然包含某个基，则该元素可以从解集中去除。  </p>
<p>3.【定理1】优胜法性能<br />
对于<strong>极大化</strong>问题，给定独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>以及费用函数<span class="arithmatex">\(c: E \rightarrow \mathbb{R}^{+}\)</span>，设<span class="arithmatex">\(G(E, \mathscr{F}, c)\)</span>为优胜贪心算法的目标函数值，<span class="arithmatex">\(OPT(E, \mathscr{F}, c)\)</span>为最优目标函数值，则：<br />
（1）<span class="arithmatex">\(\frac{G(E, \mathscr{F}, c)}{OPT(E, \mathscr{F}, c)} \ge q(E, \mathscr{F})\)</span>（优胜法目标函数值与最优目标函数值的比值，至少不小于独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>的秩商）<br />
（2）该下界是紧的，即：存在<strong>费用函数</strong><span class="arithmatex">\(c\)</span>，使得下界可以达到。<br />
【证明】<br />
命题（1）：
①假设<span class="arithmatex">\(G_n\)</span>是优胜法所得解，<span class="arithmatex">\(O_n\)</span>是最优解。记<span class="arithmatex">\(E_j = {e_1, \cdots, e_j}\)</span>，即<strong>前<span class="arithmatex">\(j\)</span>个元素组成的集合</strong>。<br />
②<strong>取交集</strong>。令<span class="arithmatex">\(G_j = G_n \cap E_j, O_j = O_n \cap E_j\)</span>；为便于变形处理，令<span class="arithmatex">\(c_{e_0} = c_{e_{n + 1}} = 0, G_0 = \emptyset\)</span>。<br />
③通过下列步骤，<strong>对<span class="arithmatex">\(G_n\)</span>的开销<span class="arithmatex">\(c(G_n)\)</span>进行拆解、变形和放缩</strong>。<br />
④变形：<span class="arithmatex">\(c(G_n) = \sum_{i = 1}^{n}(|G_j| - |G_{j - 1}|)c_{e_j}\)</span>（以<span class="arithmatex">\(E\)</span>中单个元素<span class="arithmatex">\(e_i\)</span>为单位，进行拆分）<br />
<span class="arithmatex">\(= \sum_{i = 1}^{n}|G_j|(c_{e_{j}} - c_{e_{j + 1}})\)</span>（变量提取，以<span class="arithmatex">\(|G_j|\)</span>为单位进行求和）<br />
[注]下一步是关键处理，可以按照如下几个要点进行理解：<br />
(i)首先，<span class="arithmatex">\(G_j\)</span>必定是<span class="arithmatex">\(E_j\)</span>上的一个<strong>极大独立集</strong>。<br />
(ii)一个极大独立集再添加任何元素后，不再是独立集。 <br />
(iii)从<span class="arithmatex">\(G_j\)</span>按照贪心算法选取第一个元素开始，<span class="arithmatex">\(G_j\)</span>一定是<span class="arithmatex">\(E_j\)</span>上的极大独立集；此后可以按照数学归纳法，推出<span class="arithmatex">\(G_j\)</span>是极大独立集。<br />
(iv)回顾基本概念：<span class="arithmatex">\(E_j\)</span>的下秩<span class="arithmatex">\(\rho(E_j)\)</span>，是其若干个基（极大独立集）中，<strong>最少的元素个数</strong>。<br />
(v)因此可作放缩：<span class="arithmatex">\(|G_j| \ge \rho(E_j)\)</span>。<br />
⑤放缩：<span class="arithmatex">\(c(G_n) = \sum_{i = 1}^{n}|G_j|(c_{e_{j}} - c_{e_{j + 1}}) \newline \ge \sum_{i = 1}^{n}\rho(E_j)(c_{e_j} - c_{e_{j + 1}})\)</span><br />
⑥利用秩商的基本定义<span class="arithmatex">\(q(E, \mathscr{F}) = \frac{\rho(E_j)}{r(E_j)}\)</span>，作代换：<span class="arithmatex">\(c(G_n) \ge q(E, \mathscr{F}) \sum_{i = 1}^n r(E_j)(c_{e_j} - c_{e_{j + 1}})\)</span><br />
⑦注意秩是独立系统基的元素个数的最大值，因此<span class="arithmatex">\(c(G_n) \ge q(E, \mathscr{F})\sum_{i = 1}^{n}|O_j|(c_{e_j} - c_{e_{j + 1}}) = q(E, \mathscr{F})\sum_{i = 1}^nc(e_j)(|O_j| - |O_{j - 1}|) \newline = q(E, \mathscr{F})c(O_n)\)</span><br />
⑧结论：<span class="arithmatex">\(\frac{G(E, \mathscr{F}, c)}{OPT(E, \mathscr{F}, c)} \ge q(E, \mathscr{F})\)</span><br />
命题（2）：<br />
①使用构造性证明。<br />
②设<span class="arithmatex">\(F \subset E\)</span>有且仅有两个基<span class="arithmatex">\(B_1, B_2\)</span>，并成立：<br />
<span class="arithmatex">\(\frac{|B_1|}{|B_2|} = q(E, \mathscr{F})\)</span><br />
③令费用函数<span class="arithmatex">\(c(e) = 1, e \in F; c(e) = 0, e \notin F\)</span>，并将<span class="arithmatex">\(B_1\)</span>的元素排在最前面，则贪心算法选中<span class="arithmatex">\(B_1\)</span>，最优解选中<span class="arithmatex">\(B_2\)</span>，此时恰有：<br />
<span class="arithmatex">\(\frac{G(E, \mathscr{F}, c)}{OPT(E, \mathscr{F}, c)} = \frac{|B_1|}{|B_2|} = q(E, \mathscr{F})\)</span>  </p>
<p>4.【定理2】劣汰法性能<br />
对于独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>和费用函数<span class="arithmatex">\(c: E\rightarrow \mathbb{R}^{+}\)</span>上的极小化问题，设<span class="arithmatex">\(G(E, \mathscr{F}, c)\)</span>为劣汰法所得解的开销，有：<br />
<span class="arithmatex">\(1 \le \frac{G(E, \mathscr{F}, c)}{OPT(E, \mathscr{F}, c)} \le max_{F \subset E}\frac{|F| - \rho^*(F)}{|F| - r^*(F)}\)</span>  </p>
<p>5.【例1】极大化-劣汰法、极小化-优胜法表现不佳的情况<br />
<span class="arithmatex">\(1 —— 2 —— M\)</span>
上述三点相连，数值即它们对应的开销。<br />
（1）使用劣汰法，求极小顶点覆盖的最大权。<br />
（2）使用优胜法，求极大顶点独立集的最小权。<br />
【解】<br />
（1）①一开始，<span class="arithmatex">\(F = \{e_1, e_2, e_M\}\)</span>。<br />
②“劣汰法”首先删除的是<strong>权重最小</strong>（<strong>本小问中，权重越大，优先程度越高</strong>）的<span class="arithmatex">\(e_1\)</span>，剩下<span class="arithmatex">\(e_2, e_M\)</span>。<br />
③注意到<span class="arithmatex">\(\{e_2, e_M\}\)</span>不是独立集，删除<span class="arithmatex">\(e_2\)</span>后不再形成顶点覆盖，只有被迫删除<span class="arithmatex">\(e_M\)</span>形成极小顶点覆盖。<br />
[理解]<br />
在极大化问题中使用劣汰法，一开始的算法步骤优化意图是明显的，但是可能产生非常不佳的结果。<br />
（2）①一开始，<span class="arithmatex">\(F = \emptyset\)</span>。<br />
②“优胜法”首先选择的是<strong>权重最小</strong>的（<strong>本小问中，权重越小，优先程度越高</strong>）的<span class="arithmatex">\(e_1\)</span>。<br />
③注意到：再选<span class="arithmatex">\(e_2\)</span>，解集不再是独立集，只能被迫选择<span class="arithmatex">\(e_M\)</span>形成极小顶点覆盖。<br />
[理解]<br />
在极小化问题中使用优胜法，一开始的算法步骤优化意图是明显的，但是可能产生非常不佳的结果。  </p>
<h5 id="_26">四、秩商估计式</h5>
<p>1.【定理3】秩商估计式<br />
设<span class="arithmatex">\((E, \mathscr{F})\)</span>是一个独立系统，若<span class="arithmatex">\(\forall A \in \mathscr{F}, \forall e \in E\)</span>，都有<span class="arithmatex">\(A \cup \{e\}\)</span>至多包含<span class="arithmatex">\(p\)</span>个圈，则秩商<span class="arithmatex">\(q(E, \mathscr{F}) \ge \frac{1}{p}\)</span>。  </p>
<p>2.【定理3】秩商估计式<br />
【证明思路】<br />
（1）考虑对待证条件进行强化。<br />
①待证条件是<span class="arithmatex">\(\forall F \subset E, \frac{\rho(F)}{r(F)} \ge \frac{1}{p}\)</span>，是针对<span class="arithmatex">\(F\)</span>的基中，元素个数最多、元素个数最少的两个基导出的结论，具有特殊性。<br />
②考虑强化条件：<span class="arithmatex">\(\forall F \subset E\)</span>，任取<span class="arithmatex">\(F\)</span>中的两个基<span class="arithmatex">\(J, K\)</span>，都有<span class="arithmatex">\(\frac{|J|}{|K|} \ge \frac{1}{\rho}\)</span>。这是一个更强、更普遍的结论，强化后形式上更简单，并且从已知条件看，强化后的形式可能是可行的。<br />
（2）构造与证明。<br />
①<span class="arithmatex">\(\forall F \subset E, J, K\)</span>为<span class="arithmatex">\(F\)</span>的任意两个基。需证：<span class="arithmatex">\(\frac{|J|}{|K|} \ge \frac{1}{\rho}\)</span>。<br />
②设<span class="arithmatex">\(J \backslash K = {e_1, \cdots, e_t}\)</span>，希望从<span class="arithmatex">\(K\)</span>出发，通过元素的增减形成<span class="arithmatex">\(J\)</span>。<br />
③逐个添加<span class="arithmatex">\(J \backslash K\)</span>中的元素，形成圈后，去除<span class="arithmatex">\(K \backslash J\)</span>中的元素，以破除至多<span class="arithmatex">\(p\)</span>个圈。迭代进行，直至形成<span class="arithmatex">\(J\)</span>。<br />
④注意到：破除一个圈只需去除一个元素；破除<span class="arithmatex">\(p\)</span>个圈至多需要<span class="arithmatex">\(p\)</span>个元素，并且<span class="arithmatex">\(J, K\)</span>可能有公共元素。因此结论成立。  </p>
<h4 id="_27">应用运筹学基础 第十一讲</h4>
<h5 id="_28">一、独立系统的对偶</h5>
<p>1.[定义1]对偶独立系统的基  </p>
<p>（1）<span class="arithmatex">\(B\)</span>是独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>的基<span class="arithmatex">\(\Leftrightarrow E \backslash B\)</span>是对偶独立系统<span class="arithmatex">\((E, \mathscr{F}^*)\)</span>的基。<br />
[理解]<br />
原独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>的元素集合<span class="arithmatex">\(E\)</span>，去除原独立系统一个基<span class="arithmatex">\(B\)</span>中的元素，剩下的集合即形成对偶独立系统<span class="arithmatex">\((E, \mathscr{F}^*)\)</span>的一个基。<br />
（2）对偶独立系统独立集集合<span class="arithmatex">\(\mathscr{F}^*\)</span>的定义：<br />
<span class="arithmatex">\(\mathscr{F}^* = \{Y \subset E|\exists B \in base(E, \mathscr{F})，有Y \cap B = \emptyset\}\)</span>。<br />
[理解]<br />
若<span class="arithmatex">\(Y\)</span>是元素集合<span class="arithmatex">\(E\)</span>的子集，且跟原独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>的某个基<span class="arithmatex">\(B\)</span>恰好不相交，则<span class="arithmatex">\(Y\)</span>是对偶独立系统的独立集。  </p>
<p>2.[定理1]独立系统的对偶具有自反性，即<span class="arithmatex">\((E, \mathscr{F}^{**}) = (E, \mathscr{F})\)</span>。<br />
【证明】<br />
（1）证明<span class="arithmatex">\(\mathscr{F}^{**} \subset \mathscr{F}\)</span>：
对<span class="arithmatex">\(\forall Y \in \mathscr{F}^{**}, \exists (E, \mathscr{F}^*)的基B^*,Y \cap B^* = \emptyset \newline \Leftrightarrow \exists (E, \mathscr{F})的基B, B^* = E\backslash B\)</span><br />
故<span class="arithmatex">\(Y \cap(E \backslash B) = \emptyset\)</span>，
因此<span class="arithmatex">\(Y \subset B\)</span>。<br />
（2）同理可证明<span class="arithmatex">\(\mathscr{F} \subset \mathscr{F}^{**}\)</span>。  </p>
<h5 id="_29">二、拟阵——定义与性质</h5>
<p>1.[定义2]拟阵<br />
（1）[等价定义2.1]若<span class="arithmatex">\(\forall X, Y \in \mathscr{F}\)</span>，<span class="arithmatex">\(|X| &gt; |Y| \Rightarrow \exists e \in X \backslash Y, Y \cup \{e\} \in \mathscr{F}\)</span>，则称独立系统<span class="arithmatex">\((E,\mathscr{F})\)</span>是拟阵。<br />
[理解]<br />
只要独立集<span class="arithmatex">\(X\)</span>的元素个数大于独立集<span class="arithmatex">\(Y\)</span>的元素个数，必定存在<span class="arithmatex">\(X\backslash Y\)</span>中的元素，将其加入独立集<span class="arithmatex">\(Y\)</span>后，所得集合仍然为独立集。<br />
（2）[等价定义2.2]若<span class="arithmatex">\(\forall X, Y \in \mathscr{F}, |X| = |Y| + 1 \Rightarrow\exists e \in X \backslash Y, Y \cup \{e\} \in \mathscr{F}\)</span>，则称独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>是拟阵。<br />
[理解]<br />
只要独立集<span class="arithmatex">\(X\)</span>的元素个数比独立集<span class="arithmatex">\(Y\)</span>的元素个数多一个，必定存在<span class="arithmatex">\(X\backslash Y\)</span>中的元素，将其加入独立集<span class="arithmatex">\(Y\)</span>后，所得集合仍然为独立集。<br />
（3）[等价定义2.3]若<span class="arithmatex">\(\forall F \subset E\)</span>，<span class="arithmatex">\(F\)</span>的所有基都有相同的元素个数，则称独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>是拟阵。<br />
[理解]<br />
所有极大独立集元素个数相同，是拟阵一个具有数学对称美、简洁美的性质。  </p>
<p>2.拟阵定义等价性证明<br />
（1）定义2.1和2.2的等价性显然成立。<br />
（2）定义2.1<span class="arithmatex">\(\Leftrightarrow\)</span>定义2.3
·定义2.1<span class="arithmatex">\(\Rightarrow\)</span>定义2.3，可以直接推出。<br />
·定义2.3<span class="arithmatex">\(\Rightarrow\)</span>定义2.1，考虑<span class="arithmatex">\(\forall X \ne Y\)</span>，对<span class="arithmatex">\(X \cup Y\)</span>作分解。<br />
注意到<span class="arithmatex">\(X \cup Y \subset E\)</span>，<br />
由于<span class="arithmatex">\(|X \cup Y| &gt; |Y|\)</span>，<br />
故<span class="arithmatex">\(Y\)</span>不可能是<span class="arithmatex">\(X \cup Y\)</span>的极大独立集，<br />
并且<span class="arithmatex">\(Y\)</span>只能从<span class="arithmatex">\(X \backslash Y\)</span>中选择元素进行扩充，<br />
若干次扩充后才可能成为极大独立集，<br />
因此<span class="arithmatex">\(\exists e \in X \backslash Y, Y \cup \{e\} \in \mathscr{F}\)</span>，结论得证。  </p>
<p>3.[定理2]拟阵的对偶独立系统是拟阵。  </p>
<p>4.[定理3]对于拟阵，使用优胜法、劣汰法获得的贪心解均为最优解。  </p>
<h5 id="_30">三、拟阵——举例</h5>
<p>1.图拟阵/圈拟阵/生成树拟阵<br />
·已知无向图<span class="arithmatex">\(G = (V, E)\)</span>
·元素集合<span class="arithmatex">\(E = E(G)\)</span>是无向图<span class="arithmatex">\(G\)</span>的边集<br />
·<span class="arithmatex">\(\mathscr{F} = \{F \subset E| (v(G), F)\ 是森林\}\)</span><br />
[理解]<br />
（1）图论中，所有无环图统称森林。<br />
（2）一棵生成树对应的边集，即为一个极大独立集。若再往其中添加任意一边，都会形成环路，“环路”即“圈”。<br />
[证明]<br />
（1）使用拟阵等价定义2.3进行证明，即证所有基中元素个数相等。<br />
（2）使用反证法。
假设<span class="arithmatex">\(F_1, F_2\)</span>为两个森林，且<span class="arithmatex">\(|F_1| \gt |F_2|\)</span>，
若<span class="arithmatex">\(\forall e \in F_1 \backslash F_2\)</span>，<span class="arithmatex">\(F_2 \cup \{e\}\)</span>中含有圈，
则知<span class="arithmatex">\(e = \{u, v\}\)</span>的两个顶点在<span class="arithmatex">\(F_2\)</span>中属于同一分支，
因此<span class="arithmatex">\(F_2\)</span>的分支数<span class="arithmatex">\(\le F_1\)</span>的分支数，矛盾。  </p>
<p>2.无关向量拟阵<br />
·元素集合<span class="arithmatex">\(E = {\vec{A_i}}, i = 1, \cdots, m\)</span>，即某矩阵的所有列向量。<br />
·<span class="arithmatex">\(\mathscr{F} = \{F \subset E| |F| 中向量线性无关\}\)</span>  </p>
<p>3.一致拟阵<br />
·元素集合<span class="arithmatex">\(E\)</span>：有限个元素的集合。<br />
·<span class="arithmatex">\(k:\)</span>非负整数。<br />
·<span class="arithmatex">\(\mathscr{F} = \{F \subset E | |F| \le k\}\)</span>  </p>
<p>4.无向图拟阵<br />
·给定无向图<span class="arithmatex">\(G = (V, E)\)</span>，及图上的一个“顶点独立集”<span class="arithmatex">\(S\)</span>。
[注]
①顶点独立集<span class="arithmatex">\(V' \subset V\)</span>，任取<span class="arithmatex">\(V'\)</span>种两个顶点，它们之间不存在直接相连的边。<br />
②二部图中，每一“部”即形成了一个顶点独立集。<br />
·<span class="arithmatex">\(\forall u \in S\)</span>，有参数<span class="arithmatex">\(k_u \in \mathbb{Z}_{+}\)</span>，即针对各顶点的关联边数限制。<br />
·<span class="arithmatex">\(\mathscr{F} = \{X \in E||\delta_X(u)| \le k_u, u\in S\}\)</span><br />
·<span class="arithmatex">\(\mathscr{F}\)</span>中每个边集应满足，跟顶点独立集<span class="arithmatex">\(S\)</span>相连的边数不应超过<span class="arithmatex">\(k_u\)</span>。<br />
·若<span class="arithmatex">\(X, Y \in \mathscr{F}, |X| \gt |Y|\)</span>，则可从<span class="arithmatex">\(X \backslash Y\)</span>中选边加入<span class="arithmatex">\(Y\)</span>，对<span class="arithmatex">\(Y\)</span>中关联边数尚且松弛的顶点加边即可。  </p>
<h5 id="_31">四、拟阵的交</h5>
<p>1.[定义3]拟阵的交<br />
称<span class="arithmatex">\((E, \mathscr{F}_1 \cap \mathscr{F}_2)\)</span>为拟阵<span class="arithmatex">\((E, \mathscr{F}_1)\)</span>和<span class="arithmatex">\((E, \mathscr{F}_2)\)</span>的<strong>交</strong>。  </p>
<p>2.拟阵的交的性质<br />
（1）拟阵的交必定是独立系统。<br />
（2）拟阵的交不一定是拟阵。  </p>
<p>3.[定理4]独立系统与拟阵的关系<br />
任何一个独立系统，都可以表示成有限个拟阵的交。  </p>
<p>[证明]（构造性证明）<br />
·对任一独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>，设<span class="arithmatex">\(C_i\)</span>为其上任意一个圈，<strong>不包含该圈</strong>的独立集构成集合为<span class="arithmatex">\(\mathscr{F}_i\)</span>，即：<br />
<span class="arithmatex">\(\mathscr{F}_i = \{X \in E | C_i \backslash E \neq \emptyset\}\)</span><br />
·需要证明两点：<br />
①<span class="arithmatex">\((E, \mathscr{F}_i)\)</span>是拟阵。<br />
②<span class="arithmatex">\(\cap_{i = 1}^n \mathscr{F}_i = F\)</span>。（显然成立）<br />
·证明<span class="arithmatex">\((E, \mathscr{F}_i)\)</span>是拟阵：<br />
假设<span class="arithmatex">\(X, Y \in \mathscr{F}_i, |X| \gt |Y|\)</span>，注意到<span class="arithmatex">\(C_i \backslash X \neq \emptyset, C_i \backslash Y \neq \emptyset\)</span>，分三类情况讨论。<br />
①若<span class="arithmatex">\(Y \subset X\)</span>，直接对<span class="arithmatex">\(Y\)</span>扩充即可。<br />
②若<span class="arithmatex">\(\exists e \in X \backslash Y\)</span>且<span class="arithmatex">\(e \notin C_i\)</span>，容易证明<span class="arithmatex">\(Y \cup{e_i} \in \mathscr{F}_i\)</span>。<br />
③若<span class="arithmatex">\(\forall e \in X \backslash Y,\)</span>都有<span class="arithmatex">\(e \in C_i\)</span>，则必定有<span class="arithmatex">\(|C_i \backslash Y| \ge 2\)</span>成立，从<span class="arithmatex">\(X \backslash Y\)</span>中任选一边<span class="arithmatex">\(e_i\)</span>对<span class="arithmatex">\(Y\)</span>作扩充，仍有<span class="arithmatex">\(Y \cup{e_i} \in \mathscr{F}_i\)</span>成立。<br />
综上，<span class="arithmatex">\((E, \mathscr{F}_i)\)</span>是独立系统。  </p>
<h5 id="_32">五、拟阵与秩商估计式</h5>
<p>1.[定理5]拟阵与秩商的关系<br />
若独立系统<span class="arithmatex">\((E, \mathscr{F})\)</span>是<span class="arithmatex">\(p\)</span>个拟阵之交，则<span class="arithmatex">\(q(E, \mathscr{F}) \ge \frac{1}{p}\)</span>。  </p>
<p>2.[例1]二部图匹配问题<br />
（1）二部图数学描述<br />
·<span class="arithmatex">\(G = (A \cup B, E), A \cap B = \emptyset\)</span><br />
·<span class="arithmatex">\(A, B\)</span>均为顶点独立集。<br />
（2）性质：二部图匹配可以写作两个无向图拟阵的交。<br />
·二部图匹配：<span class="arithmatex">\(\mathscr{F} = \{M \subset E | M 是图G的匹配\}\)</span><br />
·拟阵一：<span class="arithmatex">\(\mathscr{F}_1 = \{X \in E | |\delta_X(u)| \le 1, u \in A\}\)</span>（边集<span class="arithmatex">\(X\)</span>与顶点独立集<span class="arithmatex">\(A\)</span>中各顶点的关联度均不超过<span class="arithmatex">\(1\)</span>）<br />
·拟阵二：<span class="arithmatex">\(\mathscr{F}_2 = \{Y \in E | |\delta_Y(v)| \le 1, v \in B\}\)</span>（边集<span class="arithmatex">\(Y\)</span>与顶点独立集<span class="arithmatex">\(B\)</span>中各顶点的关联度均不超过<span class="arithmatex">\(1\)</span>）</p>
<h4 id="_33">应用运筹学基础 第十二讲</h4>
<h5 id="_34">一、装箱问题及其近似算法</h5>
<p>1.问题描述<br />
给定物品集合<span class="arithmatex">\(\{a_1, \cdots, a_n\}, 0 \lt a_i \le 1, i = 1, 2, \cdots, n\)</span>，箱子容量为<span class="arithmatex">\(1\)</span>，目的是用最少的单位尺寸的箱子，装入所有元素。  </p>
<p>[注]<br />
除非<span class="arithmatex">\(P = NP\)</span>，否则最优近似算法的近似比为<span class="arithmatex">\(1.5\)</span>。  </p>
<p>2.[定义1]渐近比、绝对比<br />
（1）若某问题的近似算法<span class="arithmatex">\(A\)</span>总满足：<span class="arithmatex">\(A(I) \le \alpha \cdot OPT(I) + \beta\)</span>，其中常数<span class="arithmatex">\(\alpha, \beta \in \mathbb{R}\)</span>，则称算法<span class="arithmatex">\(A\)</span>的渐近比为<span class="arithmatex">\(\alpha\)</span>。<br />
（2）<span class="arithmatex">\(\rho^{\inf} = \sup_{OPT(I) \rightarrow \infty}\frac{A(I)}{OPT(I)}\)</span><br />
（3）绝对比：<span class="arithmatex">\(\beta = 0\)</span>，且无需取<span class="arithmatex">\(OPT(I) \rightarrow \infty\)</span>的极限，随时成立<span class="arithmatex">\(A(I) \le \alpha \cdot OPT(I)\)</span>，则<span class="arithmatex">\(\alpha\)</span>的下界是近似算法的绝对比。  </p>
<p>3.装箱问题的近似性质<br />
（1）近似比：<span class="arithmatex">\(FFD(I) \le \frac{3}{2}OPT(I)\)</span><br />
（2）渐近比：<span class="arithmatex">\(FFD(I) \le \frac{11}{9}OPT(I) + \frac{6}{9}\)</span><br />
【注】<span class="arithmatex">\(FFD(I) \le \frac{11}{9}OPT(I) + 1 \rightarrow FFD(I) \le \frac{3}{2}OPT(I)\)</span><br />
（1）<span class="arithmatex">\(OPT(I) = 2, 3\)</span>，分别进行讨论。<br />
（2）<span class="arithmatex">\(OPT(I) = 4\)</span>，恒成立。  </p>
<p>4.装箱问题的<code>Any-Fit</code>算法<br />
（1）对输入不进行任何排序，是一种在线算法。<br />
（2）对于已经打开并装入一些物品的箱子，只要存在一个箱子可装新物品，就不能允许打开新的箱子。<br />
（3）具体分类<br />
·<code>First Fit</code><br />
·<code>Best Fit</code><br />
·<code>Almost Worst Fit</code>（装在物品体积第二少的箱子重，近似比较好）
·<code>Worst Fit</code>（近似比为<span class="arithmatex">\(2\)</span>）  </p>
<p>[例1]对于<code>Worst Fit</code>，设置一个无穷序列<span class="arithmatex">\(a_{2i + 1} = \frac{1}{2}, a_{2i} = \epsilon\)</span>，令<span class="arithmatex">\(\epsilon = \frac{1}{n}, n \rightarrow \infty\)</span>，则可达到算法近似比上界。  </p>
<p>5.物品分类算法<br />
（1）将规模满足<span class="arithmatex">\(\frac{1}{k+1} \le c_i \le \frac{1}{k}\)</span>的物品分为一类。<br />
（2）在类内使用<code>Next Fit</code>算法（最近打开的箱子装不下，则直接打开新箱子）。  </p>
<p>[理解]
渐近比与近似比类似，都是评价近似算法优劣的标准。  </p>
<h5 id="first-fit">二、<code>First-Fit</code>算法近似情况分析</h5>
<p>1.结论（渐近比）：<span class="arithmatex">\(FF(I) \le \frac{17}{10}OPT(I) + \frac{8}{10}\)</span> </p>
<p>2.证明思路<br />
（1）引入一种<strong>摊还</strong>的权重函数<span class="arithmatex">\(w: a_i \rightarrow \mathbb{R}\)</span><br />
（2）问题实例<span class="arithmatex">\(I\)</span>的权重和
<span class="arithmatex">\(w(I) = \sum_{i = 1}^nw(a_i)
\newline = \sum_{j = 1}^{FF(I)}w(B_j)
\newline = \sum_{l = 1}^{OPT^*(I)}w(B_l^*)\)</span>
其中<span class="arithmatex">\(B_j\)</span>表示第<span class="arithmatex">\(j\)</span>个箱子。<br />
（3）证明过程<br />
①首先构造桥梁<span class="arithmatex">\(w(I)\le 1.7OPT(I)\)</span>，即：
<span class="arithmatex">\(\forall B_l^*, w(B_l^*) \le 1.7\)</span><br />
这是这针对最优解箱子的特殊情况，可以尝试强化为<span class="arithmatex">\(\forall B, w(B) \le 1.7\)</span>。<br />
②再作证明：<span class="arithmatex">\(FF(I) \le w(I) + 0.8\)</span></p>
<p>[注]在平均意义下，<span class="arithmatex">\(w(B_j) \ge 1\)</span>。  </p>
<p>3.物品权函数构造<br />
<span class="arithmatex">\(w(a) = \frac{6}{5}a + v(a)\)</span><br />
<span class="arithmatex">\(v(a)=\left\{
\begin{matrix}
 0.4, a &gt; \frac{1}{2} \\
 0.1, \frac{1}{3} \lt a \le \frac{1}{2}\\
 \frac{3}{5}(a - \frac{1}{6}), \frac{1}{6} \lt a \le \frac{1}{3} \\
 0, a \le \frac{1}{6}
\end{matrix}
\right.\)</span>
将上述四种元素类型分别记作大、中、小、微。  </p>
<p>[注]<br />
（1）按照<span class="arithmatex">\(w(B_l) \ge 1\)</span>是否成立，对<code>First Fit</code>算法获得的箱子进行分类讨论。<br />
（2）任一<span class="arithmatex">\(w(B_l) &lt; 1\)</span>的箱子必定同时满足一下三个条件：<br />
·不含任何大元素
·至多含<span class="arithmatex">\(1\)</span>个中元素
·箱子元素规模之和<span class="arithmatex">\(&lt; \frac{5}{6}\)</span></p>
<p>4.[引理1]若<span class="arithmatex">\(c(B) \le 1\)</span>, 则<span class="arithmatex">\(w(B) \le 1.7\)</span>。<br />
[证明]<br />
（1）若<span class="arithmatex">\(B\)</span>中包含大元素，则<span class="arithmatex">\(w(B) \le 1.2 + 0.4 + 0.1 = 1.7\)</span><br />
（2）若<span class="arithmatex">\(B\)</span>中不含大元素，则<span class="arithmatex">\(w(B) \le 1.2 + 3 \times 0.1 = 1.5\)</span>  </p>
<p>5.[引理2]<br />
（1）假设<code>First Fit</code>算法获得的所有箱子中，有<span class="arithmatex">\(m\)</span>个箱子<span class="arithmatex">\(B_1, \cdots, B_m\)</span>的权值<span class="arithmatex">\(c &lt; 1\)</span>，则下式成立：<br />
<span class="arithmatex">\(\frac{6}{5}c(B_i) + v(b_{i + 1}) \ge 1, i = 1, 2, \cdots, m - 2\)</span><br />
（2）对上述箱子补充<span class="arithmatex">\(0.8\)</span>的权值后，可使所有箱子的平均权值$ \ge 1$。  </p>
<p>[证明]<br />
（1）<span class="arithmatex">\(k = 1\)</span>的情形<br />
·将此箱子<strong>跟前一个满足<span class="arithmatex">\(w(B') \ge 1\)</span>的箱子计算平均权重</strong>。<br />
·由于两个箱子的物品规模之和必定超过<span class="arithmatex">\(1\)</span>，故二者的权重和必定超过<span class="arithmatex">\(1.2\)</span>，补上<span class="arithmatex">\(0.8\)</span>的权重后，平均权重不小于<span class="arithmatex">\(1\)</span>。<br />
（2）<span class="arithmatex">\(k \ge 2\)</span>的情形<br />
①箱子元素总体积的分析<br />
·注意到若存在只装一个元素的箱子，该元素不可能是大元素，则元素体积<span class="arithmatex">\(\le 0.5\)</span>，因此这样的箱子至多存在一个，且只能是最后一个箱子。<br />
·在至少有<span class="arithmatex">\(2\)</span>个物品的箱子中，至多一个箱子物品体积<span class="arithmatex">\(\le \frac{2}{3}\)</span>，且它只能位于倒数第一或倒数第二的位置。若不存在只装一个物体，且体积<span class="arithmatex">\(\le\frac{1}{2}\)</span>的箱子，则该箱子是最后一个箱子；若存在只装一个物体，且体积<span class="arithmatex">\(\le\frac{1}{2}\)</span>的箱子，则该箱子是倒数第二个箱子。<br />
②箱子均摊权重分析<br />
·不妨设：<span class="arithmatex">\(B_i, B_{i + 1}\)</span>是两个权重<span class="arithmatex">\(\le 1\)</span>的箱子，<span class="arithmatex">\(B_{i + 1}\)</span>中有物体<span class="arithmatex">\(x, y\)</span>。<br />
·首先，<span class="arithmatex">\(B_i\)</span>的权重必定满足<span class="arithmatex">\(\frac{2}{3} \le c(B_i) \lt \frac{5}{6}\)</span>，并有结论<span class="arithmatex">\(\frac{6}{5}c(B_i) + v(B_{i + 1}) \ge 1\)</span>成立。<br />
·设<span class="arithmatex">\(c(B_i) = \frac{6}{5} - z\)</span>，由于<span class="arithmatex">\(c(x), c(y) \ge \frac{1}{6} + z\)</span>，即物体<span class="arithmatex">\(x, y\)</span>均有奖励，因此<span class="arithmatex">\(\frac{6}{5}c(B_i) + c(B_{i + 1}) \ge \frac{6}{5}(\frac{5}{6} - z) + \frac{3}{5}z + \frac{3}{5}z = 1\)</span>.  </p>
<p>6.<code>FFD(First Fit Decreasing)</code>算法<br />
（1）物体从大到小排序，再使用<code>FF</code>算法。<br />
（2）近似比：<span class="arithmatex">\(FFD(I) \le \frac{3}{2}OPT(I)\)</span>。<br />
（3）渐近比：<span class="arithmatex">\(FFD(I) \le\frac{11}{9}OPT(I) + \frac{6}{9}\)</span>  </p>
<h5 id="kkkarmarkar-karp">三、<code>KK(Karmarkar &amp; Karp)</code>算法</h5>
<p>1.算法近似比<br />
<span class="arithmatex">\(A(I) \le OPT(I) + O(log^2(OPT(I)))\)</span><br />
2.问题描述<br />
（1）数学记号<br />
·<span class="arithmatex">\(E = \{a_1, \cdots, a_m\}\)</span>表明可选物品的尺寸。<br />
·<span class="arithmatex">\(b_i\)</span>：具有尺寸<span class="arithmatex">\(a_i\)</span>的物品个数。<br />
·<span class="arithmatex">\(N\)</span>：单个箱子<code>configuration</code>的种类数。<br />
·<span class="arithmatex">\(t_{ij}\)</span>：在可行方案<span class="arithmatex">\(j\)</span>中，具有尺寸<span class="arithmatex">\(a_i\)</span>的元素个数。<br />
（2）线性规划<br />
·设单个箱子共有<span class="arithmatex">\(N\)</span>种可能的<code>configuration</code>，第<span class="arithmatex">\(j\)</span>种<code>configuration</code>的箱子使用个数为<span class="arithmatex">\(x_j\)</span>。<br />
·线性规划：<br />
<span class="arithmatex">\(min \space \sum_{j = 1}^N x_j\)</span><br />
<span class="arithmatex">\(s.t. \space \sum_{j = 1}^Nt_{ij}x_j \ge b_i, i = 1, 2 , \cdots, m\)</span>（每种物品的装配数量不低于需求数量）<br />
<span class="arithmatex">\(\space \space \space \space \space \space \space x_j \ge 0\)</span>（非负约束）<br />
3.[定理1]<br />
设<span class="arithmatex">\(s_m\)</span>是物品的最小尺寸，则上述线性规划可以在<span class="arithmatex">\(Poly(m, log\frac{n}{s_m})\)</span>时间内取得误差不超过<span class="arithmatex">\(1\)</span>的近似解。<br />
[注]<br />
（1）由于上课讲解较为粗略，本笔记跳过迭代算法。<br />
（2）小物品不影响渐近比的证明，详见作业解析。  </p>
<h4 id="_35">应用运筹学基础 第十三讲</h4>
<h5 id="_36">一、在线算法</h5>
<p>1.在线算法的基本特点 <br />
（1）输入具有序列关系，并以某种方式逐个给出。<br />
（2）未来信息未知。<br />
（3）已做的决策不可逆转。<br />
2.【定义1】竞争比<br />
设<span class="arithmatex">\(A\)</span>为在线算法，<span class="arithmatex">\(OPT\)</span>为最优离线算法。若对于最小化问题，若存在常数<span class="arithmatex">\(\alpha, \beta \in R\)</span>，使得对任意问题实例<span class="arithmatex">\(I\)</span>，都有<span class="arithmatex">\(A(I) \le \alpha \cdot OPT(I) + \beta\)</span>，则称算法<span class="arithmatex">\(A\)</span>是<span class="arithmatex">\(\alpha\)</span>-竞争的，称<span class="arithmatex">\(\alpha\)</span>的下确界为算法<span class="arithmatex">\(A\)</span>的<strong>竞争比</strong>。<br />
3.问题举例<br />
（1）滑雪租鞋问题<br />
·不知道顾客以后会去划多少次雪，决定顾客是买鞋（开销为<span class="arithmatex">\(d\)</span>）还是租鞋（开销为<span class="arithmatex">\(1\)</span>），以最小化其开销。<br />
（2）在线竞拍问题<br />
·设物品有一个不公开的整数实际价值<span class="arithmatex">\(u \le 1\)</span>，竞拍者可猜测其价值，若猜价高于实际价格，则结束拍卖，花费为各个轮次猜价之和。<br />
（3）一维搜索问题<br />
·数轴上有一个正负未知的点，从零点出发开始寻找该点。  </p>
<h5 id="k-">二、<span class="arithmatex">\(k\)</span>-服务器问题</h5>
<p>1.问题描述<br />
给定一个度量网络（即：距离满足三角不等式）<span class="arithmatex">\(G = (V, E)\)</span>，有<span class="arithmatex">\(k\)</span>个服务器位于<span class="arithmatex">\(G\)</span>的某些顶点上。设顶点访问需求序列为<span class="arithmatex">\(\sigma = (r_1, \cdots, r_n)\)</span>，且逐个到达。一旦某个<span class="arithmatex">\(r_i\)</span>出现，则需立刻派遣一个服务器前往服务。服务器移动代价与移动距离成正比，目的是服务完所有的需求后，服务器移动的总距离最小。<br />
2.贪心算法及其竞争比分析
（1）贪心算法：就近派遣。<br />
（2）一个竞争比无上界的问题实例<br />
·设直线上有<span class="arithmatex">\(A, B, C\)</span>三点，其位置关系为：<br />
<span class="arithmatex">\(A——B——————C\)</span>
其中，<span class="arithmatex">\(AB = 1, BC = M, M &gt; 1\)</span>；服务器有<span class="arithmatex">\(2\)</span>台，初始状态下分别位于顶点<span class="arithmatex">\(A,B\)</span>。 
·访问需求序列：<span class="arithmatex">\((A, C, B, A, B, A, B, \cdots)\)</span>.<br />
·最优离线算法：令左侧服务器一直驻留在<span class="arithmatex">\(A\)</span>点，右侧服务器先移动到点<span class="arithmatex">\(C\)</span>，再返回点<span class="arithmatex">\(B\)</span>，之后无需再作任何移动，移动的总距离为<span class="arithmatex">\(2M\)</span>。<br />
·贪心算法：令右侧服务器前往<span class="arithmatex">\(C\)</span>后不再返回，之后左侧服务器不断往返于<span class="arithmatex">\(A,B\)</span>两点间，移动的总距离为<span class="arithmatex">\(2M + (n - 3)\)</span>。<br />
·令<span class="arithmatex">\(n \rightarrow \infty\)</span>，可说明竞争比无上界。<br />
3.【定理1】设<span class="arithmatex">\(M\)</span>是度量空间，且<span class="arithmatex">\(M\)</span>上的图<span class="arithmatex">\(G = (V, E)\)</span>有至少<span class="arithmatex">\(k + 1\)</span>个顶点，则不存在竞争比好于<span class="arithmatex">\(k\)</span>的在线算法。<br />
【证明】<br />
·设<span class="arithmatex">\(A\)</span>是任一在线算法，构造输入序列，使得每个请求均在<span class="arithmatex">\(A\)</span>无服务器处发生，并将<span class="arithmatex">\(k\)</span>个访问需求视为一组进行分析。<br />
（1）单位边权情况：对于一组访问需求，在线算法需移动<span class="arithmatex">\(k\)</span>次服务器，离线算法只需移动<span class="arithmatex">\(1\)</span>次以覆盖至多<span class="arithmatex">\(k\)</span>个待访问的顶点。<br />
（2）任意边权情况：在均摊意义下，可说明竞争比下界为<span class="arithmatex">\(k\)</span>。<br />
·设输入序列为<span class="arithmatex">\(\sigma_1, \cdots,\sigma_k\)</span>，在线算法<span class="arithmatex">\(A\)</span>初始时在顶点<span class="arithmatex">\(v'\)</span>处无服务器。现构造<span class="arithmatex">\(k\)</span>个离线算法，使代价之和不超过<span class="arithmatex">\(A\)</span>的移动代价。具体而言，是让<span class="arithmatex">\(k\)</span>个离线算法在每一步的移动代价之和，恰好等于离线算法在该步的移动代价。  <br />
·构造一组离线算法<span class="arithmatex">\(B_1, \cdots, B_k\)</span>，满足：所有算法初始时在<span class="arithmatex">\(v'\)</span>均有服务器，但是在其余<span class="arithmatex">\(k\)</span>个顶点<span class="arithmatex">\((v_1, v_2, \cdots, v_k)\)</span>中，算法<span class="arithmatex">\(B_i\)</span>在顶点<span class="arithmatex">\(v_i\)</span>处无服务器。<br />
·若顶点<span class="arithmatex">\(v'\)</span>发出请求，设算法<span class="arithmatex">\(A\)</span>令顶点<span class="arithmatex">\(v''\)</span>移动至<span class="arithmatex">\(v'\)</span>，移动距离为<span class="arithmatex">\(d(v', v'')\)</span>。此时，有且仅有一个算法<span class="arithmatex">\(B_i\)</span>，它在顶点<span class="arithmatex">\(v''\)</span>处没有服务器，将其在<span class="arithmatex">\(v'\)</span>的服务器移动到<span class="arithmatex">\(v''\)</span>，代价为<span class="arithmatex">\(d(v', v'')\)</span>；其余算法均不移动任何服务器。在这一步骤中，<span class="arithmatex">\(k\)</span>个离线算法的总移动代价恰好等于离线算法<span class="arithmatex">\(A\)</span>的移动代价。<br />
【理解】把算法<span class="arithmatex">\(B_i\)</span>的在<span class="arithmatex">\(v'\)</span>处的服务器移动至<span class="arithmatex">\(v''\)</span>，有如下两点意义：<br />
（1）令<span class="arithmatex">\(k\)</span>个离线算法单步的移动代价之和，恰好等于在线算法的单步移动代价。<br />
（2）注意到下一个访问请求必定发生于顶点<span class="arithmatex">\(v''\)</span>，而<span class="arithmatex">\(k\)</span>个离线算法发生移动后，在顶点<span class="arithmatex">\(v''\)</span>都有服务器，在包含<span class="arithmatex">\(v'\)</span>在内的其余<span class="arithmatex">\(k\)</span>个服务器中，每个顶点分别有一个离线算法没有服务器，这是算法正确性的原因所在。  </p>
<h4 id="_37">应用运筹学基础 第十四讲</h4>
<h5 id="k-k-dcdouble-cover">一、一维<code>k</code>-服务器问题——<code>k</code>-竞争<code>DC(Double Cover)</code>算法</h5>
<p>1.<code>DC</code>算法描述<br />
对于一维<span class="arithmatex">\(k-\)</span>服务器问题，根据请求点的位置采取策略：<br />
（1）若请求点位于最左端服务器的左侧，或最右端服务器的右侧，则派遣最近服务器前往服务。<br />
（2）若请求点位于某两个服务器之间，设这两个服务器到请求点的较小距离为<span class="arithmatex">\(d\)</span>，则令两个服务器均向请求点移动距离<span class="arithmatex">\(d\)</span>。<br />
2.【定理1】<code>DC</code>算法竞争比为<span class="arithmatex">\(k\)</span>。<br />
【证明】<br />
（1）由第十三讲【定理1】，对于度量空间上的<span class="arithmatex">\(k\)</span>-服务器问题，任意在线算法竞争比必定不低于<span class="arithmatex">\(k\)</span>。<br />
（2）现证明其竞争比上界亦为<span class="arithmatex">\(k\)</span>，使用<strong>均摊分析法</strong>。<br />
·势能函数构造思想：<br />
①令<code>OPT, DC</code>算法分别作单步决策，<strong><code>OPT</code>算法先作决策和移动过，<code>DC</code>算法后作决策和移动</strong>。设<span class="arithmatex">\(\Phi_0\)</span>是势函数初始值，<span class="arithmatex">\(\Phi_i\)</span>是完成第<span class="arithmatex">\(i\)</span>步决策后势函数的值。<br />
②势函数的期望性质：若某步<span class="arithmatex">\(OPT\)</span>移动距离为<span class="arithmatex">\(d\)</span>，则势函数至多增加<span class="arithmatex">\(kd\)</span>；若某步<span class="arithmatex">\(OPT\)</span>移动距离为<span class="arithmatex">\(d\)</span>，则势函数至少减少<span class="arithmatex">\(d\)</span>。<br />
③若某个势函数能同时满足上述二条件，则有：
<span class="arithmatex">\(\Phi_n - \Phi_0 \le k \cdot OPT(\sigma)  -DC(\sigma)\)</span>
从而：
<span class="arithmatex">\(DC(\sigma) \le k \cdot OPT(\sigma) + (\Phi_0 -\Phi_n)\)</span><br />
即：<span class="arithmatex">\(k\)</span>为<code>DC</code>算法竞争比上界。<br />
·势能函数构造过程<br />
①首先关注<code>OPT, DC</code>算法<span class="arithmatex">\(k\)</span>个服务器之间最小权完美匹配的特点。对二者<span class="arithmatex">\(k\)</span>个服务器分别按照从左往右的顺序排序，记为<span class="arithmatex">\((s_1^*, s_2^*, \cdots, s_n^*)\)</span>和<span class="arithmatex">\((s_1, s_2,\cdots, s_n)\)</span>，则最小权完美匹配必定是<span class="arithmatex">\(s_i\)</span>与<span class="arithmatex">\(s_i^*\)</span>，下标相同者形成匹配；且某算法的<span class="arithmatex">\(k\)</span>个服务器在移动过程中，各服务器的左右顺序不会发生逆转，两个算法之间的最小完美匹配关系也是稳定的。<br />
②令<span class="arithmatex">\(Min\)</span>表示<code>OPT, DC</code>算法<span class="arithmatex">\(k\)</span>个服务器之间的最小权完美匹配值，<span class="arithmatex">\(s_i\)</span>是<code>DC</code>算法的服务器<span class="arithmatex">\(i\)</span>，记<span class="arithmatex">\(\Sigma = \Sigma_{i \lt j}d(s_i, s_j)\)</span>，即<code>DC</code>算法的<span class="arithmatex">\(k\)</span>个服务器两两距离之和。<br />
③势函数构造：<span class="arithmatex">\(\phi = k\cdot Min + \Sigma\)</span><br />
·势能函数变化量分析<br />
①若<code>OPT</code>算法移动距离为<span class="arithmatex">\(d\)</span>，则<span class="arithmatex">\(\Delta (\Phi) \le kd\)</span>，原因：<code>OPT</code>算法移动顶点，及与之匹配的<code>DC</code>算法顶点之间的距离至多增加<span class="arithmatex">\(d\)</span>，其余顶点对之间的距离不变。<br />
②若<code>DC</code>算法移动距离为<span class="arithmatex">\(d\)</span>，分情况讨论：<br />
一是单个服务器移动，则<span class="arithmatex">\(\Sigma\)</span>增加<span class="arithmatex">\((k - 1)d\)</span>，但是<span class="arithmatex">\(Min\)</span>减小量为<span class="arithmatex">\(d\)</span>（注意：此时<code>OPT</code>的端点服务器已经先行移动至请求点），因此：
<span class="arithmatex">\(\Delta(\Phi) = (k - 1)d - kd = -d\)</span><br />
二是<code>DC</code>算法两个服务器同时移动，则<span class="arithmatex">\(\Sigma\)</span>减小<span class="arithmatex">\(2d\)</span>，而由于必有一个服务器匹配对象为请求点，故<span class="arithmatex">\(Min\)</span>不会增加，从而<span class="arithmatex">\(\Delta(\Phi) \le -d\)</span>。<br />
因此，势能函数<span class="arithmatex">\(\phi = k\cdot Min + \Sigma\)</span>满足我们期望的性质。  </p>
<h5 id="k-_1">二、<span class="arithmatex">\(k\)</span>-服务器问题——补充与拓展</h5>
<p>1.树上的<span class="arithmatex">\(k\)</span>-服务器问题<br />
（1）顶点距离满足度量性质，任意两点间路径唯一。<br />
（2）树上<span class="arithmatex">\(k\)</span>-服务器问题的<span class="arithmatex">\(k\)</span>-竞争<code>DC</code>算法<br />
·邻居服务器定义：到某点路径上没有其余服务器的所有服务器，都是该点的邻居服务器。<br />
·算法：某点发出请求时，所有邻居服务器均发生移动。<br />
·势能函数定义与一维情况相同，即<span class="arithmatex">\(\phi = k\cdot Min + \Sigma\)</span>。<br />
2.一般图上的<span class="arithmatex">\(k\)</span>-服务器问题<br />
·动态规划在线算法可达到<span class="arithmatex">\(2k-1\)</span>竞争比。  </p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.tabs", "navigation.tabs.sticky", "header.autohide"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../assets/javascripts/bundle.e1c3ead8.min.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
      
    
  </body>
</html>